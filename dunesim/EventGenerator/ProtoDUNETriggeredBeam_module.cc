////////////////////////////////////////////////////////////////////////
// Class:       ProtoDUNETriggeredBeam
// Module Type: producer
// File:        ProtoDUNETriggeredBeam_module.cc
//
// Modified from the original ProtoDUNEBeam module to more accurately
// reflect what happens in reality. As such, it does not make use of
// the GoodParticle tree and uses the TRIG planes to work out which
// events are "Triggered" events
//
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSetRegistry.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "cetlib_except/exception.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "larcore/Geometry/Geometry.h"
#include "larcoreobj/SummaryData/RunData.h"
#include <memory>
#include <string>
#include <map>
#include <utility>
#include <vector>
// Added for ProtoDUNE beam simulation storage
//#include "lardataobj/Simulation/ProtoDUNEbeamsim.h"
#include "dune/EventGenerator/ProtoDUNEbeamDataProducts/ProtoDUNEbeamsim.h"
#include "dune/DuneObj/ProtoDUNEBeamEvent.h"
#include "lardataobj/RecoBase/TrackingTypes.h"
#include "lardataobj/RecoBase/TrackTrajectory.h"
#include "lardataobj/RecoBase/Track.h"
#include "dune/EventGenerator/ProtoDUNEbeamDataProducts/ProtoDUNEBeamInstrument.h"
//#include "dune/EventGenerator/ProtoDUNEbeamTPCmatching/ProtoDUNEbeammatch.h"
//#include "dune/EventGenerator/ProtoDUNEbeamTPCmatching/ProtoDUNETriggeredBeamToF.h"
#include "lardata/Utilities/AssociationUtil.h"
// art extensions
#include "nurandom/RandomUtils/NuRandomService.h"
#include "art_root_io/TFileService.h"
#include <TFile.h>
#include <TTree.h>
#include <TVector3.h>
#include <TLorentzVector.h>
#include <TDatabasePDG.h>
#include <TParticlePDG.h>
#include "TSystem.h"
#include "CLHEP/Random/RandFlat.h"
#include "ifdh.h"
#include <sys/stat.h>

namespace evgen{

    class ProtoDUNETriggeredBeam;
 
    class ProtoDUNETriggeredBeam : public art::EDProducer {
    public:
        explicit ProtoDUNETriggeredBeam(fhicl::ParameterSet const & p);
        // The destructor generated by the compiler is fine for classes
        // without bare pointers or other resource use.
        ~ProtoDUNETriggeredBeam();
        
        // Plugins should not be copied or assigned.
        ProtoDUNETriggeredBeam(ProtoDUNETriggeredBeam const &) = delete;
        ProtoDUNETriggeredBeam(ProtoDUNETriggeredBeam &&) = delete;
        ProtoDUNETriggeredBeam & operator = (ProtoDUNETriggeredBeam const &) = delete;
        ProtoDUNETriggeredBeam & operator = (ProtoDUNETriggeredBeam &&) = delete;
        
        // Required functions.
        void produce(art::Event & e) override;
        void beginJob() override;
        void beginRun(art::Run& run) override;
        void endJob() override;

        // Simple struct to store the information for each particle at the front face
        struct BeamParticle {
          BeamParticle(){
            fTrackID=-999;
            fPDG=-999;
            fParentID=-999;
            fPosX = -999;
            fPosY = -999;
            fPosZ = -999;
            fPosT = -999;
            fMomX = -999;
            fMomY = -999;
            fMomZ = -999; 
          };
          BeamParticle(int trackid, int pdg, int parentid, float posX, float posY, float posZ, float posT,
                       float momX, float momY, float momZ){
            fTrackID = trackid;
            fPDG     = pdg;
            fParentID= parentid;
            fPosX    = posX;
            fPosY    = posY;
            fPosZ    = posZ;  
            fPosT    = posT;
            fMomX    = momX;
            fMomY    = momY;
            fMomZ    = momZ;
          };
          void Print(){
            std::cout << "Particle " << fPDG << ": (" << fPosX << "," << fPosY << "," << fPosZ << "," << fPosT << ") "
                                     << ": (" << fMomX << "," << fMomY << "," << fMomZ << ") " << std::endl;
          };
          int fTrackID, fPDG, fParentID;
          float fPosX, fPosY, fPosZ, fPosT;
          float fMomX, fMomY, fMomZ;
        };

        // Struct to contain the particles reaching the cryostat wall for each event
        // in the beam simulation files
        struct BeamEvent {
          BeamEvent(){
            fEventID = -999;
            fTriggerID = -999;
          }
          BeamEvent(int eventid){
            fEventID = eventid;
            fTriggerID = -999;
          };

          void AddParticle(BeamParticle particle){
            fParticlesFront.insert(std::make_pair(particle.fTrackID,particle));
          };

          int fEventID;

          // Map of particles to the track ID
          std::map<int,BeamParticle> fParticlesFront;

          int fTriggerID;

          // We need information for each point in the beamline
          std::map<std::string,BeamParticle> fTriggeredParticleInfo;
        };

        // Convenience struct to encapsulate all particles that would
        // deposit energy within one readout window of the TPC
        struct OverlaidTriggerEvent {

          OverlaidTriggerEvent(int trigID){
            fTriggerEventID = trigID;
          };

          void AddOverlay(int overlayID){
            fOverlayEventIDs.push_back(overlayID);
          };

          std::vector<int> fOverlayEventIDs;
          int fTriggerEventID;

        };
        
    private:
        
        std::vector<OverlaidTriggerEvent> fAllOverlaidTriggerEvents;
        std::map<int,BeamEvent> fAllBeamEvents;
        std::vector<int> fFinalTriggerEventIDs;

        // A list of good events and an index for it.
        unsigned int fCurrentGoodEvent;
        std::vector<int> fGoodEventList;
        
        // Calculate how many overlay events we need.
        void CalculateNOverlays();
        
        // Check if a given beam event is close enough to a good particle event to be useful.
        int IsOverlayEvent(int event, int nOverlay);
        std::vector<int> GetAllOverlays(int event, int nOverlay);
        
        // Fill the above maps and vector.
        void FillParticleMaps(TTree *frontFaceTree);
       
        // Find trigger events
        std::vector<int> FindTriggeredEvents(TTree *trig1Tree,TTree *trig2Tree);
 
        // Add the triggered particle information for a given instrument
        void FillInstrumentInformation(std::vector<int> &eventIDs,TTree *instrumentTree);

        // Group the events to overlay a number of background events on each trigger event
        OverlaidTriggerEvent GenerateOverlaidEvent(const int &trigEventID);

        // Generate a true event based on a single entry from the input tree.
        void GenerateTrueEvent(simb::MCTruth &mcTruth, const OverlaidTriggerEvent &overlayEvent, beam::ProtoDUNEBeamEvent & beamEvent);

        // Convert our BeamParticle struct into a MCParticle object
        simb::MCParticle BeamParticleToMCParticle(const BeamParticle &beamParticle, const int outputTrackID, const float triggerParticleTime);
        
        // Handle root files from beam instrumentation group
        void OpenInputFile();
        
        // Convert to the detector coordinate frame
        void ConvertCoordinates(float &x, float &y, float &z);
        
        // Convert the momentum to GeV and rotate as required.
        void ConvertMomentum(float &px, float &py, float &pz);

        // We need to rotate the beam monitor coordinates into the detector frame
        TLorentzVector ConvertBeamMonitorCoordinates(float x, float y, float z, float t, float offset);

        //New for making tracks
        TVector3 ConvertProfCoordinates(double x, double y, double z, double zOffset);
        TVector3 ProjectToTPC(TVector3 firstPoint, TVector3 secondPoint);
        double GetPosition( short fiber );
        void MakeTracks( beam::ProtoDUNEBeamEvent & beamEvent );
        void MomentumSpectrometer( beam::ProtoDUNEBeamEvent & beamEvent );
        double MomentumCosTheta( double, double, double );


        TVector3 ConvertBeamMonitorMomentumVec(float px, float py, float pz);
        // Setup the beam monitor basis vectors in detector coordinates
        void BeamMonitorBasisVectors();
        // Apply the rotation
        void RotateMonitorVector(TVector3 &vec);

        void SetBeamEvent(beam::ProtoDUNEBeamEvent & beamevt, const BeamEvent &triggerEvent);
        beam::FBM MakeFiberMonitor( float pos );

 
        // Background particles need to be fired from an upstream position
        void SetBackgroundPosition(BeamParticle &particle);

        // Variables       
        CLHEP::RandFlat fFlatRnd;

        std::string fFileName;
        std::string fGoodParticleTreeName;
        std::string fAllParticlesTreeName;
        

        // The current event number. Ideally this could be an unsigned int,
        // but we will need to compare it to some ints later on.
        int fEventNumber;
        
        // Let the user define the event to start at
        int fStartEvent;

        // An important feature is to be able to use a data-driven triggered particle
        bool fUseDataDriven;
        
        TTree * fRecoTree;
        float   fXBPF697_x;
        float   fXBPF701_x;
        float   fXBPF702_x;

        float   fXBPF697_rx;
        float   fXBPF701_rx;
        float   fXBPF702_rx;

        float   fXBPF697_p;
        float   fXBPF701_p;
        float   fXBPF702_p;

        float   fXBPF697_f;
        float   fXBPF701_f;
        float   fXBPF702_f;
        float   fReco_p;

        float   fReco_tof;

        int     fNP04_PDG;
        float   fNP04front_p;

        float   fXBPF716_x;
        float   fXBPF717_y;
        float   fXBPF707_x;
        float   fXBPF708_y;

        float   fXBPF716_rx;
        float   fXBPF717_ry;
        float   fXBPF707_rx;
        float   fXBPF708_ry;

        float   fXBPF716_f;
        float   fXBPF717_f;
        float   fXBPF707_f;
        float   fXBPF708_f;

        float   fTrueFront_x;
        float   fTrueFront_y;
        float   fTrueFront_z;

        float   fTrueFront_Px;
        float   fTrueFront_Py;
        float   fTrueFront_Pz;

        float   fRecoFront_x;
        float   fRecoFront_y;
        float   fRecoFront_z;

        // Members we need to extract from the tree
        float fX, fY, fZ;
        float fPx, fPy, fPz;
        float fPDG; // Input tree has all floats

        // Event and TrackID for good particle tree
//        float fBeamEvent;
//        float fTrackID;

        // Same for all particles
        float fAllEventID;
        float fAllTrackID;

        // We need two times: the trigger time, and the time at the entry point
        // to the TPC where we generate the event.
        float fEntryT;
        
        // Define the coordinate transform from the beam frame to the detector frame
        float fBeamX;
        float fBeamY;
        float fBeamZ;
        float fBeamThetaShift;
        float fBeamPhiShift;
        float fRotateXZ;
        float fRotateYZ;
        // Rotate the beam monitor coordinate system (those after the last bending magnet)
        float fRotateMonitorXZ;
        float fRotateMonitorYZ;
        // The three beam monitor basis vectors in the detector coordinate system
        TVector3 fBMBasisX; 
        TVector3 fBMBasisY; 
        TVector3 fBMBasisZ; 
        // The z positions of the important elements along the beam direction
        float fBPROFEXTPos;
        float fBPROF4Pos;
        float fNP04frontPos;
       
        // Parameters from the .fcl file to deal with overlaying events
        float fIntensity; // Number of interactions on the secondary target per SPS spill
        float fReadoutWindow; // Readout window (needs to match the values used in the simulation) in milliseconds
        float fBeamSpillLength; // The SPS spill length in seconds

// Beam monitors resolutions
        float fT_Resolution;
        float fPos_Resolution;
        float fCh_Efficiency;

        float fLB;
/*        
        float fMagP1;
        float fMagP3;
        float fMagP4;
        float fCurrent;
*/        
        float fL1;
        float fL2;
        float fL3;
        float fBeamBend;

        float fLMag;
        float fNominalP;
        float fB;

        bool fSaveRecoTree;

        bool fReduceNP04frontArea;
        
        // Number of beam interactions to overlay.
        int fOverlays;
        
        ifdh_ns::ifdh* fIFDH;
    };
}

// Create the random number generator
namespace {
  std::string const instanceName = "protoDUNEBeam";
}


//---------------------------------------------------------------------------------
//----------------------------------------constructors-----------------------------
evgen::ProtoDUNETriggeredBeam::ProtoDUNETriggeredBeam(fhicl::ParameterSet const & pset)
  : EDProducer{pset}
    // now create the engine (for example, use art); seed will be set
    // by calling declareEngine
  , fFlatRnd(createEngine(art::ServiceHandle<rndm::NuRandomService>{}->declareEngine(instanceName),
                          "HepJamesRandom", instanceName))
{
    // Call appropriate produces<>() functions here.
    produces< std::vector<simb::MCTruth> >();
    produces< sumdata::RunData, art::InRun >();
    produces< std::vector< beam::ProtoDUNEBeamEvent > >();
    // File reading variable initialisations
    fFileName = pset.get< std::string>("FileName");
    fGoodParticleTreeName = pset.get< std::string>("GoodParticleTreeName");
    fAllParticlesTreeName = pset.get< std::string>("AllParticlesTreeName");
    std::cout << "All particles tree name = " << fAllParticlesTreeName << std::endl;
    // Intensity variables
    fIntensity = pset.get<float>("Intensity");
    fReadoutWindow = pset.get<float>("ReadoutWindow");
    fBeamSpillLength = pset.get<float>("BeamSpillLength");

// Beam monitors resolutions
    fT_Resolution = pset.get<float>("T_Resolution");
    fPos_Resolution = pset.get<float>("Pos_Resolution");
    fCh_Efficiency = pset.get<float>("Ch_Efficiency");
 
    fUseDataDriven = false;
    fReduceNP04frontArea = true;
   
    // See if the user wants to start at an event other than zero.
    fStartEvent = pset.get<int>("StartEvent");
    
    // Or maybe there was --nskip specified in the command line or skipEvents in FHiCL?
    for (auto const & p : fhicl::ParameterSetRegistry::get())
    {
        if (p.second.has_key("source.skipEvents"))
        {
            fStartEvent += p.second.get<int>("source.skipEvents");
            break; // take the first occurence
        } // no "else", if parameter not found, then just don't change anything
    }
    // ...and if there is -e option or firstEvent in FHiCL, this add up to the no. of events to skip.
    for (auto const & p : fhicl::ParameterSetRegistry::get())
    {
        if (p.second.has_key("source.firstEvent"))
        {
            int fe = p.second.get<int>("source.firstEvent") - 1; // events base index is 1
            if (fe > 0) fStartEvent += fe;
            break; // take the first occurence
        } // no "else", if parameter not found, then just don't change anything
    }
    mf::LogInfo("ProtoDUNETriggeredBeam") << "Skip " << fStartEvent << " first events from the input file.";
    
    fEventNumber = fStartEvent;
    
    // Coordinate transform
    fBeamX = pset.get<float>("BeamX");
    fBeamY = pset.get<float>("BeamY");
    fBeamZ = pset.get<float>("BeamZ");
    fBeamThetaShift = pset.get<float>("BeamThetaShift",0.0);
    fBeamPhiShift   = pset.get<float>("BeamPhiShift",0.0);
    fRotateXZ = pset.get<float>("RotateXZ"); // Only use rotation if the above aren't defined
    fRotateYZ = pset.get<float>("RotateYZ");
    
    fRotateMonitorXZ = pset.get<float>("RotateMonitorXZ");
    fRotateMonitorYZ = pset.get<float>("RotateMonitorYZ");
    fBPROFEXTPos     = pset.get<float>("BPROFEXTPosZ");
    fBPROF4Pos       = pset.get<float>("BPROF4PosZ");
    fNP04frontPos    = pset.get<float>("NP04frontPosZ");
    // Setup the beam monitor basis vectors
    BeamMonitorBasisVectors();   

    // Initialise the input file and tree to be null.
//    fInputFile = 0x0;
//    fGoodParticleTree = 0x0;
//    fAllParticlesTree = 0x0;
    fIFDH = 0;
    
    fCurrentGoodEvent = 0;

    // For momentum spectrometer
/*
    fCurrent = pset.get<float>("Current");
    fMagP1 = pset.get<float>("MagP1");
    fMagP3 = pset.get<float>("MagP3");
    fMagP4 = pset.get<float>("MagP4");
*/    
    fL1 = pset.get<float>("L1");
    fL2 = pset.get<float>("L2");
    fL3 = pset.get<float>("L3");
    fBeamBend = pset.get<float>("BeamBend");

    //New values for momentum spectrometer
    fLMag = pset.get<float>("LMag");
    fB    = pset.get<float>("B");
    fNominalP = pset.get<float>("NominalP");


/*
    fLB = fMagP1*fabs(fCurrent);
    float deltaI = fabs(fCurrent) - fMagP4;
    if(deltaI>0) fLB += fMagP3*deltaI*deltaI;

    std::cout << "Old LB: " << fLB << std::endl;
*/
    fLB = fB * fLMag * fNominalP / 7.;
//    std::cout << "New LB: " << fLB << std::endl;
    
    fSaveRecoTree = pset.get<bool>("SaveRecoTree");

    
    // Make sure we use ifdh to open the beam input file.
    OpenInputFile();
}



//-----------------------------default destructor----------------------------------
//------------------------------------------------------------------------------------
evgen::ProtoDUNETriggeredBeam::~ProtoDUNETriggeredBeam()
{
    fIFDH->cleanup();
    
}

//-------------------------------------------------------------------------------------
void evgen::ProtoDUNETriggeredBeam::beginJob(){

    art::ServiceHandle<art::TFileService> tfs;
    
    TFile *inputFile = new TFile(fFileName.c_str(),"READ");
    // Check we have the file
    if(inputFile == 0x0){
        throw cet::exception("ProtoDUNETriggeredBeam") << "Input file " << fFileName << " cannot be read.\n";
    }
    
    TTree *frontFaceTree = (TTree*)inputFile->Get(fAllParticlesTreeName.c_str());
    // Check we have the tree
    if(frontFaceTree == 0x0){
        throw cet::exception("ProtoDUNETriggeredBeam") << "Input tree " << fAllParticlesTreeName << " cannot be read.\n";
    }
    std::cout << "All particle tree " << fAllParticlesTreeName << " has " << frontFaceTree->GetEntries() << " entries" << std::endl;
   
    // Calculate the number of events to overlay
    CalculateNOverlays();

    // Fill all potential events from the NP04front tree
    FillParticleMaps(frontFaceTree);

    TTree *trig1Tree = (TTree*)inputFile->Get("VirtualDetector/TRIG1");
    TTree *trig2Tree = (TTree*)inputFile->Get("VirtualDetector/TRIG2");

    // Now search for trigger events
    std::vector<int> triggeredEventIDs =  FindTriggeredEvents(trig1Tree,trig2Tree);
    std::cout << "Proto trigger list has " << triggeredEventIDs.size() << " events" << std::endl; 

    // For triggered events, we now need to attach the other instrument information
    std::vector<std::string> otherInstrumentTreeNames;
    otherInstrumentTreeNames.push_back("VirtualDetector/TOF1");
    otherInstrumentTreeNames.push_back("VirtualDetector/BPROF1");
    otherInstrumentTreeNames.push_back("VirtualDetector/BPROF2");
    otherInstrumentTreeNames.push_back("VirtualDetector/BPROF3");
    otherInstrumentTreeNames.push_back("VirtualDetector/BPROFEXT");
    otherInstrumentTreeNames.push_back("VirtualDetector/BPROF4");
    for(const std::string treeName : otherInstrumentTreeNames){ 
      TTree *instrumentTree = (TTree*)inputFile->Get(treeName.c_str());
      FillInstrumentInformation(triggeredEventIDs,instrumentTree);
      std::cout << " - Finished adding information from " << treeName << std::endl;
    }
    std::cout << "Final trigger list has " << triggeredEventIDs.size() << " events" << std::endl; 
    fFinalTriggerEventIDs = triggeredEventIDs;

    // We are done with the input file now
    inputFile->Close();
    delete inputFile;
    inputFile = 0x0;

}

//----------------------------------------------------------------------------------------

void evgen::ProtoDUNETriggeredBeam::beginRun(art::Run& run)
{
    // Grab the geometry object to see what geometry we are using
    art::ServiceHandle<geo::Geometry> geo;
    std::unique_ptr<sumdata::RunData> runcol(new sumdata::RunData(geo->DetectorName()));
    run.put(std::move(runcol));
}

//--------------------------------------------------------------------------------------------

void evgen::ProtoDUNETriggeredBeam::endJob(){
//    fInputFile->Close();
}


//--------------------------------------------------------------------------------------------
void evgen::ProtoDUNETriggeredBeam::produce(art::Event & e)
{
    if(fEventNumber >= static_cast<int>(fFinalTriggerEventIDs.size())){
        throw cet::exception("ProtoDUNETriggeredBeam") << "Requested entry " << fEventNumber
        << " but tree only has entries 0 to "
        << fFinalTriggerEventIDs.size() - 1 << std::endl;
    }
   
    // Define the truth collection for this event.
    auto truthcol = std::make_unique< std::vector<simb::MCTruth> >();
    
    std::unique_ptr<std::vector<beam::ProtoDUNEBeamEvent> > beamData(new std::vector<beam::ProtoDUNEBeamEvent>);

    simb::MCTruth truth;
    beam::ProtoDUNEBeamEvent beamEvent; 
    // roup the events together: a triggered event with fOverlay background events
    OverlaidTriggerEvent overlayEvent = GenerateOverlaidEvent(fFinalTriggerEventIDs.at(fEventNumber));

    // Fill the MCTruth object
    GenerateTrueEvent(truth, overlayEvent, beamEvent);
    
    // Add the MCTruth to the vector
    truthcol->push_back(truth);
    
    // Finally, add the MCTruth to the event
    e.put(std::move(truthcol));

    beamData->push_back( beamEvent );
    e.put( std::move( beamData ) );

    // We have made our event, increment the event number.
    ++fEventNumber;
}
//--------------------------------------------------------------------------------------

// Fill the particle maps using the input files. This links the events of interest
// to the entry number in fAllParticlesTree.
void evgen::ProtoDUNETriggeredBeam::FillParticleMaps(TTree *frontFaceTree){
    
    float eventID, trackID, pdgCode, parentID;
    float posX, posY, posZ, posT;
    float momX, momY, momZ;

    frontFaceTree->SetBranchAddress("EventID",&eventID);
    frontFaceTree->SetBranchAddress("TrackID",&trackID);
    frontFaceTree->SetBranchAddress("PDGid",&pdgCode);
    frontFaceTree->SetBranchAddress("ParentID",&parentID);
    frontFaceTree->SetBranchAddress("x",&posX);
    frontFaceTree->SetBranchAddress("y",&posY);
    frontFaceTree->SetBranchAddress("z",&posZ);
    frontFaceTree->SetBranchAddress("t",&posT);
    frontFaceTree->SetBranchAddress("Px",&momX);
    frontFaceTree->SetBranchAddress("Py",&momY);
    frontFaceTree->SetBranchAddress("Pz",&momZ);

    // Loop over all particles and group them by events
    for(unsigned int p = 0; p < frontFaceTree->GetEntries(); ++p){

      frontFaceTree->GetEntry(p);

      // If this particle is travelling backwards then it won't hit the detector
      if(momZ < 0) continue;

      // Convert to detector coordinate system
      ConvertCoordinates(posX,posY,posZ);

      // Keep only those particles that might reach the detector
      if(fReduceNP04frontArea){
        if(posX < -500 || posX > 500) continue;
        if(posY < -150 || posY > 850) continue;
      }

      // Convert momentum
//      std::cout << "Before convert = " << momZ;
      ConvertMomentum(momX,momY,momZ);
//      std::cout << " and after = " << momZ << std::endl;

      int intEventID = static_cast<int>(eventID);
      int intTrackID = static_cast<int>(trackID);
      int intPdgCode = static_cast<int>(pdgCode);
      int intParentID= static_cast<int>(parentID);
      BeamParticle newParticle(intTrackID, intPdgCode, intParentID,
                               posX, posY, posZ, posT, momX, momY, momZ);

      std::map<int,BeamEvent>::iterator evIter = fAllBeamEvents.find(intEventID);
      if(evIter == fAllBeamEvents.end()){
        BeamEvent newBeamEvent(intEventID);
        newBeamEvent.AddParticle(newParticle);
        fAllBeamEvents.insert(std::make_pair(intEventID,newBeamEvent));
      }
      else{
        evIter->second.AddParticle(newParticle); 
      }

    }

    std::cout << "Found " << fAllBeamEvents.size() << " potential events" << std::endl;

    // Reset the branch addresses as the variables are going out of scope
    frontFaceTree->ResetBranchAddresses();
}

// Search for events that have particles in TRIG1 and TRIG2 planes
std::vector<int> evgen::ProtoDUNETriggeredBeam::FindTriggeredEvents(TTree *trig1Tree, TTree *trig2Tree){

  std::vector<int> allowedPDGs = {11,-11,13,-13,211,-211,321,-321,2212};
  
  float eventID, trackID, pdgCode, parentID;
  float posX, posY, posZ, posT;
  float momX, momY, momZ;

  // Look at trigger two first to reduce computation
  trig2Tree->SetBranchAddress("EventID",&eventID);
  trig2Tree->SetBranchAddress("TrackID",&trackID);
  trig2Tree->SetBranchAddress("PDGid",&pdgCode);
  trig2Tree->SetBranchAddress("ParentID",&parentID);
  trig2Tree->SetBranchAddress("x",&posX);
  trig2Tree->SetBranchAddress("y",&posY);
  trig2Tree->SetBranchAddress("z",&posZ);
  trig2Tree->SetBranchAddress("t",&posT);
  trig2Tree->SetBranchAddress("Px",&momX);
  trig2Tree->SetBranchAddress("Py",&momY);
  trig2Tree->SetBranchAddress("Pz",&momZ);

  // Temporarily store the particle for events with particle in TRIG2. Just store
  // the first one if there are two
  std::map<int,BeamParticle> trig2Particles;

  for(unsigned int p = 0; p < trig2Tree->GetEntries(); ++p){
  
    trig2Tree->GetEntry(p);
  
    const int intEventID = static_cast<int>(eventID);

    // If this event didn't have any particles at NP04front then move on
    if(fAllBeamEvents.find(intEventID) == fAllBeamEvents.end()) continue;

    // Carry on if we already found a particle for this event
    if(trig2Particles.find(intEventID) != trig2Particles.end()) continue;

    if(std::find(allowedPDGs.begin(),allowedPDGs.end(),static_cast<int>(pdgCode))==allowedPDGs.end()) continue;
     
    BeamParticle particle(static_cast<int>(trackID), static_cast<int>(pdgCode), static_cast<int>(parentID),
                          posX, posY, posZ, posT, momX, momY, momZ);
    trig2Particles.insert(std::make_pair(intEventID,particle));
  }

  trig2Tree->ResetBranchAddresses();

  // Now look at TRIG1
  trig1Tree->SetBranchAddress("EventID",&eventID);
  trig1Tree->SetBranchAddress("TrackID",&trackID);
  trig1Tree->SetBranchAddress("PDGid",&pdgCode);
  trig1Tree->SetBranchAddress("ParentID",&parentID);
  trig1Tree->SetBranchAddress("x",&posX);
  trig1Tree->SetBranchAddress("y",&posY);
  trig1Tree->SetBranchAddress("z",&posZ);
  trig1Tree->SetBranchAddress("t",&posT);
  trig1Tree->SetBranchAddress("Px",&momX);
  trig1Tree->SetBranchAddress("Py",&momY);
  trig1Tree->SetBranchAddress("Pz",&momZ);

  std::map<int,BeamParticle> trig1Particles;
  for(unsigned int p = 0; p < trig1Tree->GetEntries(); ++p){

    trig1Tree->GetEntry(p);
    const int intEventID = static_cast<int>(eventID);

    // Move on if this event had no particle in TRIG2
    if(trig2Particles.find(intEventID) == trig2Particles.end()) continue;

    if(std::find(allowedPDGs.begin(),allowedPDGs.end(),static_cast<int>(pdgCode))==allowedPDGs.end()) continue;
     
    BeamParticle particle(static_cast<int>(trackID), static_cast<int>(pdgCode), static_cast<int>(parentID),
                          posX, posY, posZ, posT, momX, momY, momZ);
    trig1Particles.insert(std::make_pair(intEventID,particle));
  }

  // Add the particle information at TRIG1 and TRIG2 to the triggered events
  std::vector<int> trigEventIDs;
  for(auto const &element : trig1Particles){
    BeamEvent &event = fAllBeamEvents.at(element.first);
    // Check that this makes sense... the same particle or one particle is the parent of the other
    if((element.second.fTrackID != trig2Particles.at(element.first).fTrackID) &&
       (element.second.fTrackID != trig2Particles.at(element.first).fParentID)) continue; 
    
    event.fTriggerID = trig2Particles.at(element.first).fTrackID;    
    event.fTriggeredParticleInfo.insert(std::make_pair("TRIG1",element.second));
    event.fTriggeredParticleInfo.insert(std::make_pair("TRIG2",trig2Particles.at(element.first)));
    trigEventIDs.push_back(element.first);
  }

  trig1Tree->ResetBranchAddresses();

  return trigEventIDs;
}

void evgen::ProtoDUNETriggeredBeam::FillInstrumentInformation(std::vector<int> &eventIDs, TTree *instrumentTree){

  float eventID, trackID, pdgCode, parentID;
  float posX, posY, posZ, posT;
  float momX, momY, momZ;

  instrumentTree->SetBranchAddress("EventID",&eventID);
  instrumentTree->SetBranchAddress("TrackID",&trackID);
  instrumentTree->SetBranchAddress("PDGid",&pdgCode);
  instrumentTree->SetBranchAddress("ParentID",&parentID);
  instrumentTree->SetBranchAddress("x",&posX);
  instrumentTree->SetBranchAddress("y",&posY);
  instrumentTree->SetBranchAddress("z",&posZ);
  instrumentTree->SetBranchAddress("t",&posT);
  instrumentTree->SetBranchAddress("Px",&momX);
  instrumentTree->SetBranchAddress("Py",&momY);
  instrumentTree->SetBranchAddress("Pz",&momZ);

  // Buffer all of the tree entries for trigger events
  std::map<const int,std::vector<unsigned int>> triggerIndices; 
  std::map<const int,const bool> arePionDecays;
  std::map<const int,const int> trig1TrackIDs;
  std::map<const int,const int> trig2TrackIDs;
  std::map<const int,bool> foundTrackInEvent;
  for(const int &trigEventID : eventIDs){
    BeamEvent &event = fAllBeamEvents.at(trigEventID);
    const int trig1TrackID = event.fTriggeredParticleInfo.at("TRIG1").fTrackID;
    const int trig2TrackID = event.fTriggeredParticleInfo.at("TRIG2").fTrackID;
    const int trig1TrackPDG = event.fTriggeredParticleInfo.at("TRIG1").fPDG;
    const int trig2TrackPDG = event.fTriggeredParticleInfo.at("TRIG2").fPDG;
    const bool isPionDecay = ((trig1TrackPDG==211) && (trig2TrackPDG==-13)) || 
                             ((trig1TrackPDG==-211) && (trig2TrackPDG==13));

    arePionDecays.insert(std::make_pair(trigEventID,isPionDecay));
    trig1TrackIDs.insert(std::make_pair(trigEventID,trig1TrackID));
    trig2TrackIDs.insert(std::make_pair(trigEventID,trig2TrackID));
    foundTrackInEvent.insert(std::make_pair(trigEventID,false));

    triggerIndices.insert(std::make_pair(trigEventID,std::vector<unsigned int>()));
  }



  std::string treeName = instrumentTree->GetName();
  for(unsigned int p = 0; p < instrumentTree->GetEntries(); ++p){
    instrumentTree->GetEntry(p);
    // If this isn't a triggered event then move on
    const int thisEvent = static_cast<int>(eventID);
    if(std::find(eventIDs.begin(),eventIDs.end(),thisEvent)==eventIDs.end()) continue;

    triggerIndices.at(thisEvent).push_back(p);
    const int thisParticle = static_cast<int>(trackID);
    if(trig2TrackIDs.at(thisEvent) == thisParticle){
      BeamParticle particle(static_cast<int>(trackID), static_cast<int>(pdgCode), static_cast<int>(parentID),
                            posX, posY, posZ, posT, momX, momY, momZ);
      fAllBeamEvents.at(thisEvent).fTriggeredParticleInfo.insert(std::make_pair(treeName.substr(treeName.find("/")+1),particle));
      foundTrackInEvent.at(thisEvent) = true;
    }
  }

  for(const int ev : eventIDs){
    if(foundTrackInEvent.at(ev)) continue;
    // If we didn't find TRIG2 particle, then look for the TRIG1 one
    for(const unsigned int index : triggerIndices.at(ev)){
      instrumentTree->GetEntry(index);
      const int thisEvent = static_cast<int>(eventID);
      const int thisParticle = static_cast<int>(trackID);
      if(trig1TrackIDs.at(thisEvent) == thisParticle){
        BeamParticle particle(static_cast<int>(trackID), static_cast<int>(pdgCode), static_cast<int>(parentID),
                            posX, posY, posZ, posT, momX, momY, momZ);
        fAllBeamEvents.at(thisEvent).fTriggeredParticleInfo.insert(std::make_pair(treeName.substr(treeName.find("/")+1),particle));
        foundTrackInEvent.at(thisEvent) = true;
        break;
      }
    }
  
    if(foundTrackInEvent.at(ev)) continue;
    // In the rare case that we still don't have the particle, try the TRIG1 parent
    const int parentTrack = fAllBeamEvents.at(ev).fTriggeredParticleInfo.at("TRIG1").fParentID;
    for(const unsigned int index : triggerIndices.at(ev)){
      instrumentTree->GetEntry(index);
      const int thisEvent = static_cast<int>(eventID);
      const int thisParticle = static_cast<int>(trackID);
      if(parentTrack == thisParticle){
        BeamParticle particle(static_cast<int>(trackID), static_cast<int>(pdgCode), static_cast<int>(parentID),
                            posX, posY, posZ, posT, momX, momY, momZ);
        fAllBeamEvents.at(thisEvent).fTriggeredParticleInfo.insert(std::make_pair(treeName.substr(treeName.find("/")+1),particle));
        foundTrackInEvent.at(thisEvent) = true;
        break;
      }

    }
    if(foundTrackInEvent.at(ev) == false){
      fAllBeamEvents.at(ev).fTriggerID = -999;
      // Remove this event from the input vector
      eventIDs.erase(std::remove(eventIDs.begin(),eventIDs.end(),ev),eventIDs.end());
      std::cout << "Issue found with event " << ev << ". Removing it from the trigger list - " << eventIDs.size() << " remain" << std::endl;
//      std::cout << "We didn't find tracks " << trig2TrackIDs.at(ev) << " or " << trig1TrackIDs.at(ev) << " in " << treeName << std::endl;
//      std::cout << " - PDGs: 1 = " << fAllBeamEvents.at(ev).fTriggeredParticleInfo.at("TRIG1").fPDG
//                << " and 2 = " << fAllBeamEvents.at(ev).fTriggeredParticleInfo.at("TRIG2").fPDG << std::endl;
//      for(const unsigned int index : triggerIndices.at(ev)){
//        instrumentTree->GetEntry(index);
//        std::cout << "- Choice = " << static_cast<int>(trackID) << " :: " << static_cast<int>(pdgCode) << std::endl;
    }
  }

  instrumentTree->ResetBranchAddresses();
}

// Group the events to overlay a number of background events on each trigger event
evgen::ProtoDUNETriggeredBeam::OverlaidTriggerEvent evgen::ProtoDUNETriggeredBeam::GenerateOverlaidEvent(const int &trigEventID)
{
  OverlaidTriggerEvent newTriggerEvent(trigEventID);
  // Look to see if any of these neighbouring events had particles
  for(int overlayID = trigEventID - (fOverlays / 2); overlayID < trigEventID + (fOverlays/2); ++overlayID){
    if(fAllBeamEvents.find(overlayID) == fAllBeamEvents.end()) continue;
    
    newTriggerEvent.AddOverlay(overlayID);
  }

  std::cout << "Generated final overlay event with " << newTriggerEvent.fOverlayEventIDs.size() << " overlays" << std::endl;
  return newTriggerEvent;
}

//-------------------------------------------------------------------------------------------------
void evgen::ProtoDUNETriggeredBeam::GenerateTrueEvent(simb::MCTruth &mcTruth, const OverlaidTriggerEvent &overlayEvent, beam::ProtoDUNEBeamEvent & beamEvent){
 
  // A single particle seems the most accurate description.
  mcTruth.SetOrigin(simb::kSingleParticle);

  // Get the actual triggered event first and the beam particle
  const BeamEvent trigEvent = fAllBeamEvents.at(overlayEvent.fTriggerEventID); 
  BeamParticle trigParticle = trigEvent.fParticlesFront.at(trigEvent.fTriggerID);

  // Time of the triggered particle (will make all times relative to this)
  const float triggerParticleTime = trigParticle.fPosT;

  // The track ID for primary particles in LArSoft should be negative. This is -1 for our triggered particle
  int trigOutputTrackID = -1*(mcTruth.NParticles() + 1);

  if(!fUseDataDriven){
    // Create the MCParticle for the triggered beam particle - NB the time offset sets T = 0 for this particle
    simb::MCParticle triggerParticle = BeamParticleToMCParticle(trigParticle, trigOutputTrackID, triggerParticleTime);
    mcTruth.Add(triggerParticle);

    // Fill the ProtoDUNEBeamEvent here to store beamline information
    SetBeamEvent(beamEvent,trigEvent);
    std::cout << "Created trigger MCParticle and Beamline information" << std::endl;
  }
  else{
    // Add some data driven code here
    std::cout << "Using data driven approach for triggered particle" << std::endl;
  }

  // Now let's deal with all of the background events
  for(const int &eventID : overlayEvent.fOverlayEventIDs){
    // Each overlay event needs a base time within +/- fBeamWindow of the triggered beam event
    double baseTime = (fFlatRnd.fire() - 0.5)*2.0*(fReadoutWindow*1000.*1000.);
    // Special case for triggered event
    if(overlayEvent.fTriggerEventID == eventID) baseTime = triggerParticleTime;

    for (std::pair<int,BeamParticle> element : fAllBeamEvents.at(eventID).fParticlesFront){
      // Don't double count the trigger particle
      if(overlayEvent.fTriggerEventID == eventID && element.first == trigParticle.fTrackID) continue;
      BeamParticle particle = element.second;

      const int outputTrackID =  -1*(mcTruth.NParticles() + 1);
      // For background particles we need to "back-strapolate" them to BPROFEXT so that they can hit the CRT
      SetBackgroundPosition(particle);
      simb::MCParticle backgroundParticle = BeamParticleToMCParticle(particle,outputTrackID,baseTime);
      mcTruth.Add(backgroundParticle);
    }  

  }

    // NEW APPROACH
//    OverlaidTriggerEvent spill = fAllSpills[fCurrentGoodEvent];

//    std::cout << "This spill has " << spill.fAllSpillTracks.size() << " contributing events" << std::endl;
/*
    // Find the entries that we are interested in.
    	//std::cout << "Finding all particles associated with good particle event " << std::endl;
    for(auto const & event : spill.fAllSpillTracks){

        //std::cout << " - This event has " << event.second.size() << " contributing tracks" << std::endl;

        // Is this the event we would have triggered on?
        bool trigEvent = (event.first == spill.fGoodEvent);
        float baseTime;
        if(trigEvent){
            // Set the base time for the triggered event equal to the negative of the good particle time.
            // This will be corrected later on to set the time to zero, but keep time offsets within the event.
            baseTime = -1.0 * spill.fGoodTime;
        }
        else{
            // Get a random time from -fReadoutWindow to +fReadoutWindow in ns (fReadoutWindow value is in ms).
            baseTime = (fFlatRnd.fire() - 0.5)*2.0*(fReadoutWindow*1000.*1000.);
        }
        for(auto const t : event.second){
            // Get the entry from the tree for this event and track.
            fAllParticlesTree->GetEntry(t);
            
            //std::cout << fAllEventID << ", " << fAllTrackID << ", " << spill.fGoodEvent << ", " << spill.fGoodTrack << std::endl;

            // Convert the pdgCode to an int
            int intPDG = (int)fPDG;
            // We need to ignore nuclei for now...
 /           if(intPDG > 100000){ 
              //std::cout << "Skipping nuc" << std::endl;
              continue;
            }

            // Check to see if this should be a primary beam particle (good particle) or beam background
            std::string process="primaryBackground";

            TLorentzVector pos;
            TLorentzVector mom;
            // If this track is a "good particle", use the usual "primary" tag
            if(trigEvent && (spill.fGoodTrack == (int)fAllTrackID)){
              process="primary";
              // We also need to build the momentum vector using the correct good particle information
              fGoodParticleTree->GetEntry(spill.fGoodIndex);
              pos = ConvertCoordinates(fGoodNP04front_x/10.,fGoodNP04front_y/10.,fGoodNP04front_z/10.,baseTime + fGoodNP04front_t);
              mom = MakeMomentumVector(fGoodNP04front_Px/1000.,fGoodNP04front_Py/1000.,fGoodNP04front_Pz/1000.,(int)fGoodNP04front_PDGid,true);
              if (fSaveRecoTree) {
                fTrueFront_x = pos.X();
                fTrueFront_y = pos.Y();
                fTrueFront_z = pos.Z();

                fTrueFront_Px = mom.X();
                fTrueFront_Py = mom.Y();
                fTrueFront_Pz = mom.Z();
              }
              
              SetBeamEvent(beamEvent);
              ++nBeamEvents;
            }
            else{
              // We just need to shift our background particles upstream to BPROFEXT so they will hit the CRTs
              TVector3 tempPos = GetBackgroundPosition(fX,fY,fZ,fPx,fPy,fPz); 
              // At this step the position and momentum matches the GoodPartcle coordinates so apply the same functions
              pos = ConvertCoordinates(tempPos.X()/10.,tempPos.Y()/10.,tempPos.Z()/10.,baseTime+fEntryT);
              mom = MakeMomentumVector(fPx/1000.,fPy/1000.,fPz/1000.,intPDG,false);
//              if(fabs(intPDG) == 13){
//                std::cout << "Found a " << process << " muon at time = " << baseTime+fEntryT << ":" << std::endl;
//                std::cout << fX/10. << ", " << fY/10. << ", " << fZ/10. << std::endl;
//                pos.Print();
//                mom.Vect().Unit().Print();
//              } 
            }

//            std::cout << "Information for particle " << intPDG << " with process " << process << std::endl;
//            pos.Print();
//            mom.Print();            
//            mom.Vect().Unit().Print();            
            
            // Track ID needs to be negative for primaries
            int trackID = -1*(mcTruth.NParticles() + 1); //g4trkid in larsoft
            
            // Create the particle and add the starting position and momentum
            simb::MCParticle newParticle(trackID,intPDG,process);
            newParticle.AddTrajectoryPoint(pos,mom);
            
            // Add the MCParticle to the MCTruth for the event.
            mcTruth.Add(newParticle);

            // We want to save extra information from the beam monitors for the Good Particle
            if(trigEvent && (spill.fGoodTrack == (int)fAllTrackID)){

              fGoodParticleTree->GetEntry(spill.fGoodIndex);

              sim::ProtoDUNETriggeredBeamInstrument tof1("TOF1",fGoodTOF1_x,fGoodTOF1_y,fGoodTOF1_z,fGoodTOF1_t,fGoodTOF1_Px,fGoodTOF1_Py,fGoodTOF1_Pz,fGoodTOF1_PDGid,fGoodTOF1_EventID,fGoodTOF1_TrackID,fT_Resolution);  
              sim::ProtoDUNETriggeredBeamInstrument trig2("TRIG2",fGoodTRIG2_x,fGoodTRIG2_y,fGoodTRIG2_z,fGoodTRIG2_t,fGoodTRIG2_Px,fGoodTRIG2_Py,fGoodTRIG2_Pz,fGoodTRIG2_PDGid,fGoodTRIG2_EventID,fGoodTRIG2_TrackID,fT_Resolution);  

              // For BPROF4 we want to rotate the coordinates into the detector frame
              TLorentzVector bprof4Pos = ConvertBeamMonitorCoordinates(fGoodBPROF4_x,fGoodBPROF4_y,fGoodBPROF4_z,fGoodBPROF4_t,fBPROF4Pos);
              TVector3 bprof4Mom = ConvertBeamMonitorMomentumVec(fGoodBPROF4_Px,fGoodBPROF4_Py,fGoodBPROF4_Pz);
			        sim::ProtoDUNETriggeredBeamInstrument bprof4("BPROF4",bprof4Pos.X(),bprof4Pos.Y(),bprof4Pos.Z(),fGoodBPROF4_t,bprof4Mom.X(),bprof4Mom.Y(),bprof4Mom.Z(),fGoodBPROF4_PDGid,fGoodBPROF4_EventID,fGoodBPROF4_TrackID,fPos_Resolution);

              // Same for BPROFEXT
              TLorentzVector bprofextPos = ConvertBeamMonitorCoordinates(fGoodBPROFEXT_x,fGoodBPROFEXT_y,fGoodBPROFEXT_z,fGoodBPROFEXT_t,fBPROFEXTPos);
              TVector3 bprofextMom = ConvertBeamMonitorMomentumVec(fGoodBPROFEXT_Px,fGoodBPROFEXT_Py,fGoodBPROFEXT_Pz);
        			sim::ProtoDUNETriggeredBeamInstrument bprofext("BPROFEXT",bprofextPos.X(),bprofextPos.Y(),bprofextPos.Z(),fGoodBPROFEXT_t,bprofextMom.X(),bprofextMom.Y(),bprofextMom.Z(),fGoodBPROFEXT_PDGid,fGoodBPROFEXT_EventID,fGoodBPROFEXT_TrackID,fPos_Resolution);

//              std::cout << "Predicted detector position" << std::endl;
//              TVector3 predDir = (bprof4Pos.Vect()-bprofextPos.Vect()).Unit();
//              float projDist = (fNP04frontPos - fBPROF4Pos) + fabs(fBeamZ*10./fBMBasisZ.Z());
//              (bprof4Pos.Vect() + projDist*predDir).Print();

			sim::ProtoDUNETriggeredBeamInstrument trig1("TRIG1",fGoodTRIG1_x,fGoodTRIG1_y,fGoodTRIG1_z,fGoodTRIG1_t,fGoodTRIG1_Px,fGoodTRIG1_Py,fGoodTRIG1_Pz,fGoodTRIG1_PDGid,fGoodTRIG1_EventID,fGoodTRIG1_TrackID,fT_Resolution);
			sim::ProtoDUNETriggeredBeamInstrument bprof3("BPROF3",fGoodBPROF3_x,fGoodBPROF3_y,fGoodBPROF3_z,fGoodBPROF3_t,fGoodBPROF3_Px,fGoodBPROF3_Py,fGoodBPROF3_Pz,fGoodBPROF3_PDGid,fGoodBPROF3_EventID,fGoodBPROF3_TrackID,fPos_Resolution);
			sim::ProtoDUNETriggeredBeamInstrument bprof2("BPROF2",fGoodBPROF2_x,fGoodBPROF2_y,fGoodBPROF2_z,fGoodBPROF2_t,fGoodBPROF2_Px,fGoodBPROF2_Py,fGoodBPROF2_Pz,fGoodBPROF2_PDGid,fGoodBPROF2_EventID,fGoodBPROF2_TrackID,fPos_Resolution);
			sim::ProtoDUNETriggeredBeamInstrument bprof1("BPROF1",fGoodBPROF1_x,fGoodBPROF1_y,fGoodBPROF1_z,fGoodBPROF1_t,fGoodBPROF1_Px,fGoodBPROF1_Py,fGoodBPROF1_Pz,fGoodBPROF1_PDGid,fGoodBPROF1_EventID,fGoodBPROF1_TrackID,fPos_Resolution);

// Adding Cherenkovs with same variables as BPROFEXT except for their response
sim::ProtoDUNETriggeredBeamInstrument cherenkov1("CHERENKOV1",fGoodBPROFEXT_x,fGoodBPROFEXT_y,fGoodBPROFEXT_z,fGoodBPROFEXT_t,fGoodBPROFEXT_Px,fGoodBPROFEXT_Py,fGoodBPROFEXT_Pz,fGoodBPROFEXT_PDGid,fGoodBPROFEXT_EventID,fGoodBPROFEXT_TrackID,fCh_Efficiency);
sim::ProtoDUNETriggeredBeamInstrument cherenkov2("CHERENKOV2",fGoodBPROFEXT_x,fGoodBPROFEXT_y,fGoodBPROFEXT_z,fGoodBPROFEXT_t,fGoodBPROFEXT_Px,fGoodBPROFEXT_Py,fGoodBPROFEXT_Pz,fGoodBPROFEXT_PDGid,fGoodBPROFEXT_EventID,fGoodBPROFEXT_TrackID,fCh_Efficiency);


			sim::ProtoDUNEbeamsim temp; 
                        temp.AddInstrument(tof1);
                        temp.AddInstrument(trig2);
                        temp.AddInstrument(bprof4);
                        temp.AddInstrument(bprofext);
                        temp.AddInstrument(trig1);
                        temp.AddInstrument(bprof3);
                        temp.AddInstrument(bprof2);
                        temp.AddInstrument(bprof1);
                        temp.AddInstrument(cherenkov1);
                        temp.AddInstrument(cherenkov2);

//                        std::cout << "ProtoDUNEbeamsim object has " << temp.NInstruments() << " beam instruments" << std::endl;
//std::cout << "TOF1 resolution: " << fT_Resolution << std::endl;

                        beamsimcol.push_back(temp);
//                        std::cout<< beamsimcol.size() << std::endl;
                        // std::cout<<" test value beam profile monitor: TTREE   "<<fGoodBPROF4_x<<std::endl;
//                        std::cout<<"From TTree TRIG2_TRACKID: "<<fGoodTRIG2_TrackID<<std::endl;
//                        std::cout<<"From ProtoDUNETriggeredBeamInstrument: "<<tof1.GetT()<<std::endl;
//                        std::cout<<"From ProtoDUNETriggeredBeamInstrument: "<<tof1.GetSmearedVar1()<<std::endl;


                        // std::cout<<"the testing for beam profile monitor information:  "<<fGoodBPROF4_z<<std::endl;
                        
                        
//                        std::cout<< "From the data product:  TRIG2TRACKID:   "<<temp.get_TRIG2_TrackID()<<std::endl;
                        //check the last index of the vector
                        sim::ProtoDUNEbeamsim lastelement = beamsimcol.back();
                        
//                        std::cout<<"From the vector TRIG2_TRACKID: "<<lastelement.get_TRIG2_TrackID()<<std::endl;
                        
                        
                        //Make the assn                                                                                                                                  
			//util::CreateAssn(*this, e, *beamsimcol, newParticle, *beamsimassn)
                        

            } // End beam instrumentation section
            
        } // End loop over interesting tracks for each event
    } // End loop over the vector of interesting events

    mf::LogInfo("ProtoDUNETriggeredBeam") << "Got " << nBeamEvents << " beam events";
    mf::LogInfo("ProtoDUNETriggeredBeam") << "Created event with " << mcTruth.NParticles() << " particles.";
    
    // Move on the good event iterator
    ++fCurrentGoodEvent;
*/
    std::cout << "Created event with " << mcTruth.NParticles() << " particles." << std::endl;
}

simb::MCParticle evgen::ProtoDUNETriggeredBeam::BeamParticleToMCParticle(const BeamParticle &beamParticle, const int outputTrackID, const float timeOffset){

  std::string process = "primaryBackground";
  if(outputTrackID == -1) process = "primary";

  simb::MCParticle newParticle(outputTrackID,beamParticle.fPDG,process);

  // Get the position four-vector
  TLorentzVector pos(beamParticle.fPosX,beamParticle.fPosY,beamParticle.fPosZ,beamParticle.fPosT - timeOffset);

  // Get the mass to calculate the momentum four-vector
  const TDatabasePDG* databasePDG = TDatabasePDG::Instance();
  const TParticlePDG* definition = databasePDG->GetParticle(beamParticle.fPDG);
  const float mass = definition->Mass();
  const float energy = sqrt(mass*mass + TVector3(beamParticle.fMomX,beamParticle.fMomY,beamParticle.fMomZ).Mag2());

  TLorentzVector mom(beamParticle.fMomX,beamParticle.fMomY,beamParticle.fMomZ,energy);

  // Add the single trajectory point to the MCParticle
  newParticle.AddTrajectoryPoint(pos,mom);
  return newParticle;
}

//---------------------------------------------------------------------------------------

// Function written in similar way as "openDBs()" in CORSIKAGen_module.cc
void evgen::ProtoDUNETriggeredBeam::OpenInputFile()
{
    // Setup ifdh object
    if (!fIFDH)
    {
        fIFDH = new ifdh_ns::ifdh;
    }
    
    const char* ifdh_debug_env = std::getenv("IFDH_DEBUG_LEVEL");
    if ( ifdh_debug_env )
    {
        mf::LogInfo("ProtoDUNETriggeredBeam") << "IFDH_DEBUG_LEVEL: " << ifdh_debug_env<<"\n";
        fIFDH->set_debug(ifdh_debug_env);
    }
    
    std::string path(gSystem->DirName(fFileName.c_str()));
    std::string pattern(gSystem->BaseName(fFileName.c_str()));
    
    auto flist = fIFDH->findMatchingFiles(path,pattern);
    if (flist.empty())
    {
        struct stat buffer;
        if (stat(fFileName.c_str(), &buffer) != 0)
        {
            throw cet::exception("ProtoDUNETriggeredBeam") << "No files returned for path:pattern: "<<path<<":"<<pattern<<std::endl;
        }
        else
        {
            mf::LogInfo("ProtoDUNETriggeredBeam") << "For "<< fFileName <<"\n";
        }
    }
    else
    {
        std::pair<std::string, long> f = flist.front();
        
        mf::LogInfo("ProtoDUNETriggeredBeam") << "For "<< fFileName <<"\n";
        
        // Do the fetching, store local filepaths in locallist
        
        mf::LogInfo("ProtoDUNETriggeredBeam")
        << "Fetching: " << f.first << " " << f.second <<"\n";
        std::string fetchedfile(fIFDH->fetchInput(f.first));
        MF_LOG_DEBUG("ProtoDUNETriggeredBeam") << " Fetched; local path: " << fetchedfile;
        
        fFileName = fetchedfile;
    }
}


//----------------------------------------------------------------------------------

void evgen::ProtoDUNETriggeredBeam::ConvertCoordinates(float &x, float &y, float &z){
    
    // Convert to cm and shift to the detector coordinate frame
    x = (x/10.) + fBeamX;
    y = (y/10.) + fBeamY;
    z = fBeamZ; // Just use the z position    
}

//--------------------------------------------------------------------------------

void evgen::ProtoDUNETriggeredBeam::ConvertMomentum(float &px, float &py, float &pz){
    
    // Convert to GeV
    px = px / 1000.;
    py = py / 1000.;
    pz = pz / 1000.;
   
    // If we want to rotate by changing theta and phi, do it here.
    TVector3 momVec(px,py,pz);    
    momVec.SetTheta(momVec.Theta() + fBeamThetaShift);
    momVec.SetPhi(momVec.Phi() + fBeamPhiShift);

    px = momVec.X();
    py = momVec.Y();
    pz = momVec.Z();
}

//-----------------------------------------------------------------------------

void evgen::ProtoDUNETriggeredBeam::CalculateNOverlays(){
    
    // The number of events to overlay is as follows:
    // N = Intensity * 2.0 * ReadoutWindow / BeamSpillLength
    fOverlays = fIntensity * (2.0 * fReadoutWindow / 1000.) / fBeamSpillLength;
    std::cout << "Number of overlays = " << fOverlays << std::endl;   
}


//-------------------------------------------------------------------------------
int evgen::ProtoDUNETriggeredBeam::IsOverlayEvent(int event, int nOverlay){
    
    // Check if this event lies within nOverlay/2 of each
    for(auto const e : fGoodEventList){
        if(fabs(event - e) < nOverlay/2){
            return e;
        }
    }
    return -1;
}


//---------------------------------------------------------------------------------
std::vector<int> evgen::ProtoDUNETriggeredBeam::GetAllOverlays(int event, int nOverlay){
    
    std::vector<int> nMatches;
    for(auto const e : fGoodEventList){
        if(fabs(event - e) < nOverlay/2){
            nMatches.push_back(e);
        }
    }
    return nMatches;
    
}
//----------------------------------------------------------------------------------

// We need to rotate the beam monitor coordinates into the detector frame (matching NP04front)
// This means they can later be treated in the same way as the standard NP04front positions
TLorentzVector evgen::ProtoDUNETriggeredBeam::ConvertBeamMonitorCoordinates(float x, float y, float z, float t, float zOffset){

  float off = fNP04frontPos - zOffset;

  TLorentzVector old(x,y,z,t);

  // Convert the coordinates using the rotated basis vectors
  float newX = x*fBMBasisX.X() + y*fBMBasisY.X() + (z-zOffset)*fBMBasisZ.X() + off*fabs(fBMBasisZ.X());
  float newY = x*fBMBasisX.Y() + y*fBMBasisY.Y() + (z-zOffset)*fBMBasisZ.Y() + off*fabs(fBMBasisZ.Y());
  float newZ = x*fBMBasisX.Z() + y*fBMBasisY.Z() + (z-zOffset) - off*fabs(fBMBasisZ.Z());

  // Account for the small differences between NP04front and the detector coordinates
  newX += fBeamX*10.;
  newY += fBeamY*10.;
  newZ += fBeamZ*10.;

  // Make our new beam monitor position in the detector coordinate system
  TLorentzVector result(newX,newY,newZ,t);

//  std::cout << "Coordinate transform..." << std::endl;
//  old.Print();
//  result.Print();

  return result;
}

TVector3 evgen::ProtoDUNETriggeredBeam::ConvertProfCoordinates(double x, double y, double z, double zOffset){
  double off = fNP04frontPos - zOffset;

  TVector3 old(x,y,z);

  double newX = x*fBMBasisX.X() + y*fBMBasisY.X() + /*(z-zOffset)*fBMBasisZ.X()*/ + off*fabs(fBMBasisZ.X());
  double newY = x*fBMBasisX.Y() + y*fBMBasisY.Y() + /*(z-zOffset)*fBMBasisZ.Y()*/ + off*fabs(fBMBasisZ.Y());
  double newZ = x*fBMBasisX.Z() + y*fBMBasisY.Z() + /*(z-zOffset)              */ - off*fabs(fBMBasisZ.Z());

  newX += fBeamX*10.;
  newY += fBeamY*10.;
  newZ += fBeamZ*10.;

  TVector3 result(newX/10., newY/10., newZ/10.);
  return result;
}

TVector3 evgen::ProtoDUNETriggeredBeam::ConvertBeamMonitorMomentumVec(float px, float py, float pz){

  TVector3 newMom(px,py,pz);
//  std::cout << "Momentum transform..." << std::endl;
//  newMom.Unit().Print();
  RotateMonitorVector(newMom);
//  newMom.Unit().Print();
  return newMom;
}

void evgen::ProtoDUNETriggeredBeam::BeamMonitorBasisVectors(){

  fBMBasisX = TVector3(1.,0.,0.);
  fBMBasisY = TVector3(0.,1.,0.);
  fBMBasisZ = TVector3(0.,0.,1.);
  RotateMonitorVector(fBMBasisX);
  RotateMonitorVector(fBMBasisY);
  RotateMonitorVector(fBMBasisZ);

}

void evgen::ProtoDUNETriggeredBeam::RotateMonitorVector(TVector3 &vec){

  // Note: reordering how these are done in order to keep the basis
  //       vectors of the monitors parallel to the ground. 
  vec.RotateX( fRotateMonitorYZ * TMath::Pi() / 180. );
  vec.RotateY( fRotateMonitorXZ * TMath::Pi() / 180. );

}

void evgen::ProtoDUNETriggeredBeam::SetBackgroundPosition(BeamParticle &particle){

  const TVector3 pos(particle.fPosX,particle.fPosY,particle.fPosZ);
  const TVector3 dir = TVector3(particle.fMomX,particle.fMomY,particle.fMomZ).Unit();

  // Want to move the position upstream by a distance equal to fNP04frontPos - fBPROFEXTPos
  // This length is in the beam direction frame unless we account for it
  // Convert the instrument positions from mm to cm
  const float shiftLength = (fNP04frontPos - fBPROFEXTPos)/(10.0*fBMBasisZ.Z());

  const TVector3 shiftedPos = pos - shiftLength*dir;

  particle.fPosX = shiftedPos.X();
  particle.fPosY = shiftedPos.Y();
  particle.fPosZ = shiftedPos.Z();
}


void evgen::ProtoDUNETriggeredBeam::SetBeamEvent(beam::ProtoDUNEBeamEvent & beamevt, const BeamEvent &triggerEvent){

  // TOF first
  const float trig2Time = triggerEvent.fTriggeredParticleInfo.at("TOF1").fPosT;
  const float tof1Time  = triggerEvent.fTriggeredParticleInfo.at("TRIG2").fPosT;
  beamevt.SetTOFs(std::vector<double>{trig2Time - tof1Time});
  beamevt.SetTOFChans( std::vector<int>{ 0 } );
  beamevt.SetUpstreamTriggers( std::vector<size_t>{0} );
  beamevt.SetDownstreamTriggers( std::vector<size_t>{0} );
  beamevt.SetCalibrations( 0., 0., 0., 0. );
  beamevt.DecodeTOF();

  // Fibre monitors
  const BeamParticle &bprof1Particle = triggerEvent.fTriggeredParticleInfo.at("BPROF1");
  const BeamParticle &bprof2Particle = triggerEvent.fTriggeredParticleInfo.at("BPROF2");
  const BeamParticle &bprof3Particle = triggerEvent.fTriggeredParticleInfo.at("BPROF3");
  const BeamParticle &bprofExtParticle = triggerEvent.fTriggeredParticleInfo.at("BPROFEXT");
  const BeamParticle &bprof4Particle = triggerEvent.fTriggeredParticleInfo.at("BPROF4");
  // (x,y) for BPROF1
  beamevt.SetFBMTrigger( "XBPF022697", MakeFiberMonitor( bprof1Particle.fPosX ) );
  beamevt.SetFBMTrigger( "XBPF022698", MakeFiberMonitor( bprof1Particle.fPosY ) );
  // Just x for BPROF2 and BPROF3
  beamevt.SetFBMTrigger( "XBPF022701", MakeFiberMonitor( bprof2Particle.fPosX ) );
  beamevt.SetFBMTrigger( "XBPF022702", MakeFiberMonitor( bprof3Particle.fPosX ) );
  // (x,y) for BPROFEXT
  beamevt.SetFBMTrigger( "XBPF022707", MakeFiberMonitor( bprofExtParticle.fPosX ) );
  beamevt.SetFBMTrigger( "XBPF022708", MakeFiberMonitor( bprofExtParticle.fPosY ) );
  // (x,y) for BPROF4
  beamevt.SetFBMTrigger( "XBPF022716", MakeFiberMonitor( bprof4Particle.fPosX ) );
  beamevt.SetFBMTrigger( "XBPF022717", MakeFiberMonitor( bprof4Particle.fPosY ) );

  // Cherenkovs aren't simulated, so set to dummy values
  beam::CKov dummy;
  dummy.trigger = 0;
  dummy.pressure = 0.;
  dummy.timeStamp = 0.;
  beamevt.SetCKov0( dummy );
  beamevt.SetCKov1( dummy );

  // Trigger information
  beamevt.SetMagnetCurrent( 0. );
  beamevt.SetTimingTrigger( 12 );
  beamevt.SetActiveTrigger(0);
  beamevt.SetT0( std::make_pair(0.,0.) );
 
  // Do the beamline instrumentation reconstruction
  MakeTracks( beamevt );
  MomentumSpectrometer( beamevt );

/*  
  //This will just use the class members
  beamevt.SetTOFs( std::vector<double>{ fGoodTRIG2_t - fGoodTOF1_t } );
  beamevt.SetTOFChans( std::vector<int>{ 0 } );
  beamevt.SetUpstreamTriggers( std::vector<size_t>{0} );
  beamevt.SetDownstreamTriggers( std::vector<size_t>{0} );
  beamevt.SetCalibrations( 0., 0., 0., 0. );
  beamevt.DecodeTOF();

  beamevt.SetMagnetCurrent( 0. );
  beamevt.SetTimingTrigger( 12 );

  beam::CKov dummy;
  dummy.trigger = 0;
  dummy.pressure = 0.;
  dummy.timeStamp = 0.;
  beamevt.SetCKov0( dummy );
  beamevt.SetCKov1( dummy );

  beamevt.SetActiveTrigger(0);
  beamevt.SetT0( std::make_pair(0.,0.) );

  beamevt.SetFBMTrigger( "XBPF022697", MakeFiberMonitor( fGoodBPROF1_x ) );
  beamevt.SetFBMTrigger( "XBPF022698", MakeFiberMonitor( fGoodBPROF1_y ) );
  beamevt.SetFBMTrigger( "XBPF022701", MakeFiberMonitor( fGoodBPROF2_x ) );
  beamevt.SetFBMTrigger( "XBPF022702", MakeFiberMonitor( fGoodBPROF3_x ) );

  beamevt.SetFBMTrigger( "XBPF022707", MakeFiberMonitor( fGoodBPROFEXT_x ) );
  beamevt.SetFBMTrigger( "XBPF022708", MakeFiberMonitor( fGoodBPROFEXT_y ) );

  beamevt.SetFBMTrigger( "XBPF022716", MakeFiberMonitor( fGoodBPROF4_x ) );
  beamevt.SetFBMTrigger( "XBPF022717", MakeFiberMonitor( fGoodBPROF4_y ) );

  MakeTracks( beamevt );
  MomentumSpectrometer( beamevt );


  if( fSaveRecoTree ){ 
    fReco_p = beamevt.GetRecoBeamMomentum(0);
    fReco_tof = beamevt.GetTOF();
    std::cout << "TOF: " << beamevt.GetTOFs()[0] << " " << beamevt.GetTOF() << std::endl;
    fNP04_PDG = fGoodNP04front_PDGid;

    fNP04front_p = sqrt( fGoodNP04front_Px * fGoodNP04front_Px 
                       + fGoodNP04front_Py * fGoodNP04front_Py 
                       + fGoodNP04front_Pz * fGoodNP04front_Pz );

    fXBPF697_p = sqrt( fGoodBPROF1_Px * fGoodBPROF1_Px 
                     + fGoodBPROF1_Py * fGoodBPROF1_Py 
                     + fGoodBPROF1_Pz * fGoodBPROF1_Pz );

    fXBPF701_p = sqrt( fGoodBPROF2_Px*fGoodBPROF2_Px 
                     + fGoodBPROF2_Py*fGoodBPROF2_Py 
                     + fGoodBPROF2_Pz*fGoodBPROF2_Pz );

    fXBPF702_p = sqrt( fGoodBPROF3_Px*fGoodBPROF3_Px 
                     + fGoodBPROF3_Py*fGoodBPROF3_Py 
                     + fGoodBPROF3_Pz*fGoodBPROF3_Pz );
    fXBPF697_x = fGoodBPROF1_x;
    fXBPF701_x = fGoodBPROF2_x;
    fXBPF702_x = fGoodBPROF3_x;

    fXBPF716_x = fGoodBPROF4_x;
    fXBPF717_y = fGoodBPROF4_y;
    fXBPF707_x = fGoodBPROFEXT_x;
    fXBPF708_y = fGoodBPROFEXT_y;

    
    fXBPF697_f = beamevt.GetFBM( "XBPF022697" ).active[0];
    fXBPF701_f = beamevt.GetFBM( "XBPF022701" ).active[0];
    fXBPF702_f = beamevt.GetFBM( "XBPF022702" ).active[0];

    fXBPF707_f = beamevt.GetFBM( "XBPF022707" ).active[0];
    fXBPF708_f = beamevt.GetFBM( "XBPF022708" ).active[0];
    fXBPF716_f = beamevt.GetFBM( "XBPF022716" ).active[0];
    fXBPF717_f = beamevt.GetFBM( "XBPF022717" ).active[0];

    fXBPF697_rx = GetPosition( fXBPF697_f ); 
    fXBPF701_rx = GetPosition( fXBPF701_f ); 
    fXBPF702_rx = GetPosition( fXBPF702_f ); 
                                         
    fXBPF716_rx = GetPosition( fXBPF716_f ); 
    fXBPF717_ry = GetPosition( fXBPF717_f ); 
    fXBPF707_rx = GetPosition( fXBPF707_f ); 
    fXBPF708_ry = GetPosition( fXBPF708_f ); 

    //fTrueFront_x = fGoodNP04front_x + fBeamX;
    //fTrueFront_y = fGoodNP04front_y + fBeamY;
    //fTrueFront_z = fGoodNP04front_z + fBeamZ;

    fRecoFront_x = beamevt.GetBeamTrack(0).End().X();
    fRecoFront_y = beamevt.GetBeamTrack(0).End().Y();
    fRecoFront_z = beamevt.GetBeamTrack(0).End().Z();

    fRecoTree->Fill();
  }
*/
}

beam::FBM evgen::ProtoDUNETriggeredBeam::MakeFiberMonitor( float pos ){
  beam::FBM theFBM;

  //I should probably just make this into
  //a constructor for the FBM...
  theFBM.ID = -1;
  theFBM.glitch_mask = {};
  std::uninitialized_fill( std::begin(theFBM.fiberData), std::end(theFBM.fiberData), 0. );
  std::uninitialized_fill( std::begin(theFBM.timeData), std::end(theFBM.timeData), 0. );
  theFBM.timeStamp = 0.;

  short f = 96 -  short( floor(pos) ) - 1;
  theFBM.fibers[f] = 1;
  theFBM.active.push_back(f);
  theFBM.decoded = true;

  return theFBM; 
}

double evgen::ProtoDUNETriggeredBeam::GetPosition( short fiber ){
  return ((96 - fiber) - .5);
}

void evgen::ProtoDUNETriggeredBeam::MakeTracks( beam::ProtoDUNEBeamEvent & beamEvent ){
  
  //We should only have one active fiber at a time
  //
  //Might need to ask Leigh, etc. if it's possible
  //to have multiple particles going through at the
  //same time. In which case -- try to implement it
  
  short fx1 = beamEvent.GetFBM( "XBPF022707" ).active[0];
  short fy1 = beamEvent.GetFBM( "XBPF022708" ).active[0];

  double x1 = GetPosition( fx1 );
  double y1 = GetPosition( fy1 );

  TVector3 pos1 = ConvertProfCoordinates( x1, y1, 0., fBPROFEXTPos );

  short fx2 = beamEvent.GetFBM( "XBPF022716" ).active[0];
  short fy2 = beamEvent.GetFBM( "XBPF022717" ).active[0];

  double x2 = GetPosition( fx2 );
  double y2 = GetPosition( fy2 );

  TVector3 pos2 = ConvertProfCoordinates( x2, y2, 0., fBPROF4Pos );
 
  std::vector< TVector3 > thePoints = { pos1, pos2, ProjectToTPC( pos1, pos2 ) };
  std::vector< TVector3 > theMomenta = {
    ( pos2 - pos1 ).Unit(),
    ( pos2 - pos1 ).Unit(),
    ( pos2 - pos1 ).Unit()
  };

  beamEvent.AddBeamTrack(
    recob::Track(
      recob::TrackTrajectory(recob::tracking::convertCollToPoint( thePoints ),
                             recob::tracking::convertCollToVector( theMomenta ),
                             recob::Track::Flags_t( thePoints.size() ),
                             false ),
      0, -1., 0, recob::tracking::SMatrixSym55(), recob::tracking::SMatrixSym55(), 1 
    )
  );
    
}

TVector3 evgen::ProtoDUNETriggeredBeam::ProjectToTPC(TVector3 firstPoint, TVector3 secondPoint){
  TVector3 dR = (secondPoint - firstPoint);
  
  double deltaZ = -1.*secondPoint.Z();
  double deltaX = deltaZ * (dR.X() / dR.Z());
  double deltaY = deltaZ * (dR.Y() / dR.Z());

  TVector3 lastPoint = secondPoint + TVector3(deltaX, deltaY, deltaZ);
  return lastPoint;
}

void evgen::ProtoDUNETriggeredBeam::MomentumSpectrometer( beam::ProtoDUNEBeamEvent & beamEvent ){

  short f1 = beamEvent.GetFBM( "XBPF022697" ).active[0];
  short f2 = beamEvent.GetFBM( "XBPF022701" ).active[0];
  short f3 = beamEvent.GetFBM( "XBPF022702" ).active[0];

  double x1 = -1.e-3 * GetPosition( f1 );
  double x2 = -1.e-3 * GetPosition( f2 );
  double x3 = -1.e-3 * GetPosition( f3 );

  double cos_theta = MomentumCosTheta( x1, x2, x3 );
  double momentum = 299792458*fLB/(1.E9 * acos(cos_theta));
  beamEvent.AddRecoBeamMomentum( momentum );

}

double evgen::ProtoDUNETriggeredBeam::MomentumCosTheta(double x1, double x2, double x3){
  double a =  (x2*fL3 - x3*fL2)*cos(fBeamBend)/(fL3-fL2);

 
  double numTerm = (a - x1)*( (fL3 - fL2)*tan(fBeamBend) + (x3 - x2)*cos(fBeamBend) ) + fL1*( fL3 - fL2 );

  double denomTerm1, denomTerm2, denom;
  denomTerm1 = sqrt( fL1*fL1 + (a - x1)*(a - x1) );
  denomTerm2 = sqrt( TMath::Power( ( (fL3 - fL2)*tan(fBeamBend) + (x3 - x2)*cos(fBeamBend) ),2)
                   + TMath::Power( ( (fL3 - fL2) ),2) );
  denom = denomTerm1 * denomTerm2;

  double cosTheta = numTerm/denom;  
  return cosTheta;
}

DEFINE_ART_MODULE(evgen::ProtoDUNETriggeredBeam)

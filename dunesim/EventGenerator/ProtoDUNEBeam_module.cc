////////////////////////////////////////////////////////////////////////
// Class:       ProtoDUNEBeam
// Module Type: producer
// File:        ProtoDUNEBeam_module.cc
//
// Generated at Thu Nov 17 11:20:31 2016 by Leigh Howard Whitehead,42 3-039,+41227672470, using artmod
// from cetpkgsupport v1_11_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "cetlib/exception.h"

#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "larcore/Geometry/Geometry.h"
#include "larcoreobj/SummaryData/RunData.h"

#include <memory>
#include <string>

// art extensions
#include "nutools/RandomUtils/NuRandomService.h"

#include <TFile.h>
#include <TTree.h>
#include <TVector3.h>
#include <TLorentzVector.h>
#include <TDatabasePDG.h>
#include <TParticlePDG.h>
#include "TSystem.h" 

#include "CLHEP/Random/RandFlat.h"
#include "ifdh.h" 

namespace evgen{
  class ProtoDUNEBeam;

  class ProtoDUNEBeam : public art::EDProducer {
  public:
    explicit ProtoDUNEBeam(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.
    ~ProtoDUNEBeam();

    // Plugins should not be copied or assigned.
    ProtoDUNEBeam(ProtoDUNEBeam const &) = delete;
    ProtoDUNEBeam(ProtoDUNEBeam &&) = delete;
    ProtoDUNEBeam & operator = (ProtoDUNEBeam const &) = delete;
    ProtoDUNEBeam & operator = (ProtoDUNEBeam &&) = delete;

    // Required functions.
    void produce(art::Event & e) override;
    void beginJob() override;
    void beginRun(art::Run& run) override;
    void endJob() override;

  private:

    // Generate a true event based on a single entry from the input tree.
    void GenerateTrueEvent(simb::MCTruth &mcTruth);
    
    // Handle root files from beam instrumentation group
    void OpenInputFile();

    // Generate a TLorentzVector for position making sure we get the
    // coordinates as we need them. 
    TLorentzVector ConvertCoordinates(float x, float y, float z, float t);

    // Make the momentum vector, rotating as required.
    TLorentzVector MakeMomentumVector(float px, float py, float pz, int pdg);

    std::string fFileName;
    std::string fTreeName;

    // The current event number. Ideally this could be an unsigned int,
    // but we will need to compare it to some ints later on. 
    int fEventNumber;

    // Let the user define the event to start at
    int fStartEvent;

    TFile* fInputFile;
    // Input file provides a TTree that we need to read.
    TTree* fInputTree;
  
    // Members we need to extract from the tree
    float fX, fY, fZ;
    float fPx, fPy, fPz;
    float fPDG; // Input tree has all floats
    // We need two times: the trigger time, and the time at the entry point
    // to the TPC where we generate the event.
    float fEntryT, fTriggerT;

    // Define the coordinate transform from the beam frame to the detector frame
    float fBeamX;
    float fBeamY;
    float fBeamZ;
    float fRotateXZ;
    float fRotateYZ;
    
    ifdh_ns::ifdh* fIFDH;
  };
}

evgen::ProtoDUNEBeam::ProtoDUNEBeam(fhicl::ParameterSet const & pset)
{

  // Call appropriate produces<>() functions here.
  produces< std::vector<simb::MCTruth> >();
  produces< sumdata::RunData, art::InRun >();

  // File reading variable initialisations
  fFileName = pset.get< std::string>("FileName");
  fTreeName = pset.get< std::string>("TreeName");

  // See if the user wants to start at an event other than zero.
  fStartEvent= pset.get<int>("StartEvent");
  fEventNumber = fStartEvent;

  // Coordinate transform
  fBeamX = pset.get<float>("BeamX");
  fBeamY = pset.get<float>("BeamY");
  fBeamZ = pset.get<float>("BeamZ");
  fRotateXZ = pset.get<float>("RotateXZ");
  fRotateYZ = pset.get<float>("RotateYZ");

  // Initialise the input file and tree to be null.
  fInputFile = 0x0;
  fInputTree = 0x0;
  fIFDH = 0;
  
  OpenInputFile();

}

evgen::ProtoDUNEBeam::~ProtoDUNEBeam()
{
	fIFDH->cleanup();
}

void evgen::ProtoDUNEBeam::beginJob(){

  fInputFile = new TFile(fFileName.c_str(),"READ");
  // Check we have the file
  if(fInputFile == 0x0){
    throw cet::exception("ProtoDUNEBeam") << "Input file " << fFileName << " cannot be read.\n";
  }

  fInputTree = (TTree*)fInputFile->Get(fTreeName.c_str());
  // Check we have the tree
  if(fInputTree == 0x0){
    throw cet::exception("ProtoDUNEBeam") << "Input tree " << fTreeName << " cannot be read.\n";
  }

  // Since this is technically an ntuple, all objects are floats
  // Position four-vector components
  fInputTree->SetBranchAddress("Lag_ENTRY_x",&fX);
  fInputTree->SetBranchAddress("Lag_ENTRY_y",&fY);
  fInputTree->SetBranchAddress("Lag_ENTRY_z",&fZ);
  fInputTree->SetBranchAddress("Lag_ENTRY_t",&fEntryT);
  // Momentum components
  fInputTree->SetBranchAddress("Lag_ENTRY_Px",&fPx);
  fInputTree->SetBranchAddress("Lag_ENTRY_Py",&fPy);
  fInputTree->SetBranchAddress("Lag_ENTRY_Pz",&fPz);
  // Trigger time
  fInputTree->SetBranchAddress("TRIG2_t",&fTriggerT);
  // PDG code
  fInputTree->SetBranchAddress("Lag_ENTRY_PDGid",&fPDG);
  
}

void evgen::ProtoDUNEBeam::beginRun(art::Run& run)
{
  // Grab the geometry object to see what geometry we are using
  art::ServiceHandle<geo::Geometry> geo;
  std::unique_ptr<sumdata::RunData> runcol(new sumdata::RunData(geo->DetectorName()));
  
  run.put(std::move(runcol));
}
                   
void evgen::ProtoDUNEBeam::endJob(){
  fInputFile->Close();
}

void evgen::ProtoDUNEBeam::produce(art::Event & e)
{

  // Define the truth collection for this event.
  auto truthcol = std::make_unique< std::vector<simb::MCTruth> >();
  simb::MCTruth truth;

  // Fill the MCTruth object  
  GenerateTrueEvent(truth);

  // Add the MCTruth to the vector
  truthcol->push_back(truth);

  // Finally, add the MCTruth to the event
  e.put(std::move(truthcol));

  // We have made our event, increment the event number.
  ++fEventNumber;
}

// Actually produce the MCTruth object from the input particle.
void evgen::ProtoDUNEBeam::GenerateTrueEvent(simb::MCTruth &mcTruth){

  // Check we haven't exceeded the length of the input tree
  if(fEventNumber >= fInputTree->GetEntries()){
    throw cet::exception("ProtoDUNEBeam") << "Requested entry " << fEventNumber 
                                    << " but tree only has entries 0 to " 
                                    << fInputTree->GetEntries() - 1 << std::endl; 
  }

  // For now we assume that one entry in the tree corresponds to a whole event.
  // This will have to be revisited once halo muons are included.
  fInputTree->GetEntry(fEventNumber);

  // A single particle seems the most accurate description.
  mcTruth.SetOrigin(simb::kSingleParticle);

  // Get the time of the entry into the detector relative to the trigger.
  // This might change in future, but will serve as T0 for now.
  float correctedTime = fEntryT - fTriggerT;

  // Since the tree is actually an ntuple, everything is stored as a float. 
  // Most things want the PDG code as an int, so make one.
  int intPDG = (int)fPDG;
  
  // Get the position four vector, converting mm to cm 
  TLorentzVector pos = ConvertCoordinates(fX/10.,fY/10.,fZ/10.,correctedTime);
  // Get momentum four vector, remembering to convert MeV to GeV
  TLorentzVector mom = MakeMomentumVector(fPx/1000.,fPy/1000.,fPz/1000.,intPDG);

  // Create the particle and add the starting position and momentum
  std::string process="primary";
  simb::MCParticle newParticle(-1,intPDG,process);
  newParticle.AddTrajectoryPoint(pos,mom);

  // Add the MCParticle to the MCTruth for the event.
  mcTruth.Add(newParticle);
}

// Function written in similar way as "openDBs()" in CORSIKAGen_module.cc  
void evgen::ProtoDUNEBeam::OpenInputFile()
{	
	// Setup ifdh object
	if (!fIFDH) 
	{	
		fIFDH = new ifdh_ns::ifdh;
	}
	
	const char* ifdh_debug_env = std::getenv("IFDH_DEBUG_LEVEL");
	if ( ifdh_debug_env ) 
	{
      mf::LogInfo("ProtoDUNEBeam") << "IFDH_DEBUG_LEVEL: " << ifdh_debug_env<<"\n";
      fIFDH->set_debug(ifdh_debug_env);
	}
	
	std::string path(gSystem->DirName(fFileName.c_str()));
	std::string pattern(gSystem->BaseName(fFileName.c_str()));
	
	auto flist = fIFDH->findMatchingFiles(path,pattern);
	if (flist.empty())
	{
		throw cet::exception("ProtoDUNEBeam") << "No files returned for path:pattern: "<<path<<":"<<pattern<<std::endl;
	}
	
	std::pair<std::string, long> f = flist.front();
	
	mf::LogInfo("ProtoDUNEBeam") << "For "<<fFileName<<"\n";
	
	// Do the fetching, store local filepaths in locallist
	
	mf::LogInfo("ProtoDUNEBeam")
        << "Fetching: " << f.first << " " << f.second <<"\n";       
	std::string fetchedfile(fIFDH->fetchInput(f.first));
	LOG_DEBUG("ProtoDUNEBeam") << " Fetched; local path: " << fetchedfile;
}

TLorentzVector evgen::ProtoDUNEBeam::ConvertCoordinates(float x, float y, float z, float t){

  float finalX = x + fBeamX;
  float finalY = y + fBeamY;
  float finalZ = (z - z) + fBeamZ; // Just use the z position

  TLorentzVector newPos(finalX,finalY,finalZ,t);
  return newPos;
}

TLorentzVector evgen::ProtoDUNEBeam::MakeMomentumVector(float px, float py, float pz, int pdg){

  float rotationXZ = fRotateXZ;
  float rotationYZ = fRotateYZ; 

  // Make the momentum vector and rotate it
  TVector3 momVec(px,py,pz);
  momVec.RotateY(rotationXZ * TMath::Pi() / 180.);
  momVec.RotateX(rotationYZ * TMath::Pi() / 180.);

  // Find the particle mass so we can form the energy
  const TDatabasePDG* databasePDG = TDatabasePDG::Instance();
  const TParticlePDG* definition = databasePDG->GetParticle(pdg);
  float mass = definition->Mass();

  float energy = sqrt(mass*mass + momVec.Mag2());
  
  TLorentzVector newMom(momVec,energy);
  return newMom; 
}

DEFINE_ART_MODULE(evgen::ProtoDUNEBeam)


////////////////////////////////////////////////////////////////////////
// Class:       ProtoDUNETriggeredBeam
// Module Type: producer
// File:        ProtoDUNETriggeredBeam_module.cc
//
// Modified from the original ProtoDUNEBeam module to more accurately
// reflect what happens in reality. As such, it does not make use of
// the GoodParticle tree and uses the TRIG planes to work out which
// events are "Triggered" events
//
// Leigh Whitehead & Jake Calcutt
//
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSetRegistry.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "cetlib_except/exception.h"
#include "cetlib/search_path.h"
#include "cetlib/filesystem.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "larcore/Geometry/Geometry.h"
#include "larcoreobj/SummaryData/RunData.h"
#include <memory>
#include <string>
#include <map>
#include <utility>
#include <vector>
#include "dunecore/DuneObj/ProtoDUNEBeamEvent.h"
// art extensions
#include "nurandom/RandomUtils/NuRandomService.h"
#include "art_root_io/TFileService.h"
#include <TSystem.h>
#include <TFile.h>
#include <TTree.h>
#include <TGraph.h>
#include <TVector3.h>
#include "THnSparse.h"
#include "TH2D.h"
#include "TRandom3.h"
#include <TLorentzVector.h>
#include <TDatabasePDG.h>
#include <TParticlePDG.h>
#include "CLHEP/Random/RandFlat.h"
#include "ifdh.h"
#include <sys/stat.h>

#include "dunesim/EventGenerator/Utils/ProtoDUNETriggeredBeamUtils.h"

namespace evgen{

    class ProtoDUNETriggeredBeam;
 
    class ProtoDUNETriggeredBeam : public art::EDProducer {
    public:
        explicit ProtoDUNETriggeredBeam(fhicl::ParameterSet const & p);
        // The destructor generated by the compiler is fine for classes
        // without bare pointers or other resource use.
        ~ProtoDUNETriggeredBeam();
        
        // Plugins should not be copied or assigned.
        ProtoDUNETriggeredBeam(ProtoDUNETriggeredBeam const &) = delete;
        ProtoDUNETriggeredBeam(ProtoDUNETriggeredBeam &&) = delete;
        ProtoDUNETriggeredBeam & operator = (ProtoDUNETriggeredBeam const &) = delete;
        ProtoDUNETriggeredBeam & operator = (ProtoDUNETriggeredBeam &&) = delete;
        
        // Required functions.
        void produce(art::Event & e) override;
        void beginJob() override;
        void beginRun(art::Run& run) override;
        void endJob() override;

    private:

        // Calculate how many overlay events we need.
        void CalculateNOverlays();
        
        // Group the events to overlay a number of background events on each trigger event
        OverlaidTriggerEvent GenerateOverlaidEvent(const int &trigEventID);

        // Generate a true event based on a single entry from the input tree.
        void GenerateTrueEvent(simb::MCTruth &mcTruth, const OverlaidTriggerEvent &overlayEvent, beam::ProtoDUNEBeamEvent & beamEvent);

        // Convert our BeamParticle struct into a MCParticle object
        simb::MCParticle BeamParticleToMCParticle(
            const BeamParticle &beamParticle, const int outputTrackID,
            const float triggerParticleTime, const int primaryStatus,
            const std::string process, const int motherID = -1);

        // Use DDMC to create a primary beam particle
        simb::MCParticle DataDrivenMCParticle(
            const BeamParticle &beamParticle, const int outputTrackID,
            const float triggerParticleTime,
            beam::ProtoDUNEBeamEvent & beamEvent, const int primaryStatus, const std::string process);

        void SetDataDrivenPosMom(TLorentzVector & position,
                                 TLorentzVector & momentum, double sampledHUp,
                                 double sampledVUp, double sampledHDown,
                                 double sampledVDown, double sampledMomentum,
                                 int beamPDG);

        double UnsmearMomentum2D(double momentum, int pdg);

        void SetDataDrivenBeamEvent(
            beam::ProtoDUNEBeamEvent & beamEvent,
            double sampledHUp, double sampledVUp, double sampledHDown,
            double sampledVDown, double sampledMomentum);

        void ConvertSamplingPoint(double input_point[5],
                                  std::vector<double> minima,
                                  std::vector<double> maxima,
                                  double output_point[5]);

        // Handle root files from beam instrumentation group
        void OpenInputFile(std::string & filename);
        
        TVector3 ProjectToTPC(TVector3 firstPoint, TVector3 secondPoint);
        double GetPosition( short fiber );
        void MakeTracks( beam::ProtoDUNEBeamEvent & beamEvent );
        void MomentumSpectrometer( beam::ProtoDUNEBeamEvent & beamEvent );
        double MomentumCosTheta( double, double, double );
        std::string FindFile(const std::string filename);

        TVector3 ConvertBeamMonitorMomentumVec(float px, float py, float pz);
        // Setup the beam monitor basis vectors in detector coordinates
        void BeamMonitorBasisVectors();
        // Apply the rotation
        void RotateMonitorVector(TVector3 &vec);
        // Fill all of the ProtoDUNEBeamEvent information from the beam simulation trigger event
        void SetBeamEvent(beam::ProtoDUNEBeamEvent & beamevt, const BeamEvent &triggerEvent);
        beam::FBM MakeFiberMonitor( float pos );

        // Background particles need to be fired from an upstream position
        void SetBackgroundPosition(BeamParticle &particle);

        // Variables       
        CLHEP::RandFlat fFlatRnd;

        // Distinguishes for running NP04 vs NP02
        bool fIsNP02;

        //Will rotate beam into correct position for NP02  
        double fNP02Rotation;
        bool fNP02XDrift;

        //Names of detectors in real life
        std::string DetNameBProf1X;
        std::string DetNameBProf1Y;
        std::string DetNameBProf2;
        std::string DetNameBProf3;
        std::string DetNameBProfExtX;
        std::string DetNameBProfExtY;
        std::string DetNameBProf4X;
        std::string DetNameBProf4Y;

        // Can stream with XRootD over using ifdh
        bool fStreamInput;

        // Beam input file name and tree names (in beam order)
        std::string fFileName;
        std::string fBaseFileName;
        std::string fTOF1TreeName;
        std::string fBPROF1TreeName;
        std::string fBPROF2TreeName;
        std::string fBPROF3TreeName;
        std::string fTRIG1TreeName;
        std::string fBPROFEXTTreeName;
        std::string fBPROF4TreeName;
        std::string fTRIG2TreeName;
        std::string fNP04frontTreeName;

        // Variables for the beam simulation event building        
        std::vector<OverlaidTriggerEvent> fAllOverlaidTriggerEvents;
        std::map<int,BeamEvent> fAllBeamEvents;
        std::vector<int> fFinalTriggerEventIDs;
       
        // This event refers to the position in the list of beam simulation events 
        int fEventNumber;
        
        // Let the user define the event to start at
        int fStartEvent;

        // An important feature is to be able to use a data-driven triggered particle
        bool fUseDataDriven;
        
        // Define the coordinate transform from the beam frame to the detector frame
        float fBeamX;
        float fBeamY;
        float fBeamZ;
        float fBeamThetaShift;
        float fBeamPhiShift;
        // Rotate the beam monitor coordinate system (those after the last bending magnet)
        float fRotateMonitorXZ;
        float fRotateMonitorYZ;
        // The three beam monitor basis vectors in the detector coordinate system
        TVector3 fBMBasisX; 
        TVector3 fBMBasisY; 
        TVector3 fBMBasisZ; 
        // The z positions of the important elements along the beam direction
        float fBPROFEXTPos;
        float fBPROF4Pos;
        float fNP04frontPos;
        float fTRIG2Pos;
       
        // Parameters from the .fcl file to deal with overlaying events
        float fIntensity; // Number of interactions on the secondary target per SPS spill
        float fReadoutWindow; // Readout window (needs to match the values used in the simulation) in milliseconds
        float fBeamSpillLength; // The SPS spill length in seconds

        float fLB;
        float fL1;
        float fL2;
        float fL3;
        float fBeamBend;

        float fLMag;
        std::string fNominalP;
        float fB;

        int fMaxSamples;

        TRandom3 fRNG;
        bool fVerbose, fIncludeAnti;
        std::vector<double> fMinima = {0.8, 0., 0., 0., 0.};
        std::vector<double> fMaxima = {1.2, 192., 192., 192., 192.};
        std::map<int, std::string> fPDGToName = {
          {2212, "Protons"},
          {211, "Pions"},
          {-11, "Electrons"},
          {-13, "Muons"},
          {321, "Kaons"},
          {-211, "Pions"},
          {11, "Electrons"},
          {13, "Muons"},
          {-321, "Kaons"}
        };

        std::string fSamplingFileName;
        std::string fResolutionFileName;
        TFile * fSamplingFile;
        TFile * fResolutionFile;
        std::map<std::string, THnSparseD *> fPDFs;
        std::map<std::string, TH2D *> fResolutionHists2D;
        void Setup1GeV(); //Shared by 2GeV
        void Setup3GeV();
        void Setup6GeV(); //Shared by 7GeV
        
        void Scale2DRes();
        void SetMinMax();

        std::string GetPrimaryEndProcess(const int &primary_pdg, const std::vector<int> & secondary_pdgs);
        std::string GetSecondaryProcess(const int &primary_pdg, const int &secondary_pdg);

        bool fSaveOutputTree;
        TTree * fOutputTree;
        TGraph * fTriggersGraph;
        int fOutputPDG;
        int fOutputEvent;
        double fOutputMomentum;
        double fOutputUnsmearedMomentum;
        double fOutputHUpstream, fOutputVUpstream;
        double fOutputHDownstream, fOutputVDownstream;

        bool fReduceNP04frontArea;

        evgen::ProtoDUNETriggeredBeamUtils fBeamUtils;
        
        // Number of beam interactions to overlay.
        int fOverlays;
        
        ifdh_ns::ifdh* fIFDH;
    };
}

// Create the random number generator
namespace {
  std::string const instanceName = "protoDUNEBeam";
}

using evgen::BeamParticle, evgen::BeamEvent, evgen::OverlaidTriggerEvent;

//---------------------------------------------------------------------------------
//----------------------------------------constructors-----------------------------
evgen::ProtoDUNETriggeredBeam::ProtoDUNETriggeredBeam(fhicl::ParameterSet const & pset)
  : EDProducer{pset}
    // now create the engine (for example, use art); seed will be set
    // by calling declareEngine
  , fFlatRnd(createEngine(art::ServiceHandle<rndm::NuRandomService>{}->declareEngine(instanceName),
                          "HepJamesRandom", instanceName)),
    fBeamUtils(evgen::ProtoDUNETriggeredBeamUtils(pset))
{
    // Call appropriate produces<>() functions here.
    produces< std::vector<simb::MCTruth> >();
    produces< sumdata::RunData, art::InRun >();
    produces< std::vector< beam::ProtoDUNEBeamEvent > >();
    // File reading variable initialisations
    fFileName = pset.get< std::string>("FileName");
    fBaseFileName = fFileName.substr(fFileName.rfind("/")+1);
    fStreamInput = pset.get<bool>("StreamInput", false);

    fIsNP02 = pset.get<bool>("IsNP02", false);
    //Names of the detectors in real life
    if (fIsNP02) {
      DetNameBProf1X = "XBPF021655";
      DetNameBProf1Y = "";
      DetNameBProf2 = "XBPF021659";
      DetNameBProf3 = "XPBF";
      DetNameBProfExtX = "";
      DetNameBProfExtY = "";
      DetNameBProf4X = "XBPF021669";
      DetNameBProf4Y = "XBPF021670";//Dummy for now 
    }
    else {
      DetNameBProf1X   = "XBPF022697";
      DetNameBProf1Y   = "XBPF022698";
      DetNameBProf2    = "XBPF022701";
      DetNameBProf3    = "XBPF022702";
      DetNameBProfExtX = "XBPF022707";
      DetNameBProfExtY = "XBPF022708";
      DetNameBProf4X   = "XBPF022716";
      DetNameBProf4Y   = "XBPF022717";
    }

    fNP02XDrift = pset.get<bool>("NP02XDrift", true);
    fNP02Rotation = pset.get<double>("NP02Rotation", 0.);

    // Tree names
    fTOF1TreeName      = pset.get<std::string>("TOF1TreeName");
    fBPROF1TreeName    = pset.get<std::string>("BPROF1TreeName");
    fBPROF2TreeName    = pset.get<std::string>("BPROF2TreeName");
    fBPROF3TreeName    = pset.get<std::string>("BPROF3TreeName");
    fTRIG1TreeName     = pset.get<std::string>("TRIG1TreeName");
    fBPROFEXTTreeName  = pset.get<std::string>("BPROFEXTTreeName", "");
    fBPROF4TreeName    = pset.get<std::string>("BPROF4TreeName");
    fTRIG2TreeName      = pset.get<std::string>("TRIG2TreeName");
    fNP04frontTreeName = pset.get<std::string>("NP04frontTreeName");

    // Intensity variables
    fIntensity = pset.get<float>("Intensity");
    fReadoutWindow = pset.get<float>("ReadoutWindow");
    fBeamSpillLength = pset.get<float>("BeamSpillLength");

    fUseDataDriven = pset.get<bool>("UseDataDrivenPrimary");
    fReduceNP04frontArea = pset.get<bool>("ReduceNP04frontArea");
   
    // See if the user wants to start at an event other than zero.
    fStartEvent = pset.get<int>("StartEvent");
    
    // Or maybe there was --nskip specified in the command line or skipEvents in FHiCL?
    for (auto const & p : fhicl::ParameterSetRegistry::get())
    {
        if (p.second.has_key("source"))
        {
          // Need to add in another layer here because of some change (maybe in art?) 
          if (p.second.has_key("source.skipEvents")) 
          {
            fStartEvent += p.second.get<int>("source.skipEvents");
            break; // take the first occurence
          }
        } // no "else", if parameter not found, then just don't change anything
    }
    // ...and if there is -e option or firstEvent in FHiCL, this add up to the no. of events to skip.
    for (auto const & p : fhicl::ParameterSetRegistry::get())
    {
        if (p.second.has_key("source"))
        {
          if (p.second.has_key("source.firstEvent"))
          {
              int fe = p.second.get<int>("source.firstEvent") - 1; // events base index is 1
              if (fe > 0) fStartEvent += fe;
              break; // take the first occurence
          } // no "else", if parameter not found, then just don't change anything
        }
    }
    mf::LogInfo("ProtoDUNETriggeredBeam") << "Skip " << fStartEvent << " first events from the input file.";
    
    fEventNumber = fStartEvent;
    
    // Coordinate transform
    fBeamX = pset.get<float>("BeamX");
    fBeamY = pset.get<float>("BeamY");
    fBeamZ = pset.get<float>("BeamZ");
    fBeamThetaShift = pset.get<float>("BeamThetaShift",0.0);
    fBeamPhiShift   = pset.get<float>("BeamPhiShift",0.0);

    
    fRotateMonitorXZ = pset.get<float>("RotateMonitorXZ");
    fRotateMonitorYZ = pset.get<float>("RotateMonitorYZ");
    fBPROFEXTPos     = pset.get<float>("BPROFEXTPosZ");
    fBPROF4Pos       = pset.get<float>("BPROF4PosZ");
    fTRIG2Pos        = pset.get<float>("TRIG2PosZ");
    fNP04frontPos    = pset.get<float>("NP04frontPosZ");
    // Setup the beam monitor basis vectors
    BeamMonitorBasisVectors();   

    fIFDH = 0;
    
    fL1 = pset.get<float>("L1");
    fL2 = pset.get<float>("L2");
    fL3 = pset.get<float>("L3");
    fBeamBend = pset.get<float>("BeamBend");

    //New values for momentum spectrometer
    fLMag = pset.get<float>("LMag");
    fB    = pset.get<float>("B");
    fNominalP = pset.get<std::string>("NominalP");
    fLB = fB * fLMag * std::stod(fNominalP) / 7.;

    fMaxSamples = pset.get<int>("MaxSamples", 0);

    fRNG = TRandom3(pset.get<int>("Seed", 0));
    fVerbose = pset.get<bool>("Verbose", false);
    fIncludeAnti = pset.get<bool>("IncludeAnti", false);
    fResolutionFileName = pset.get<std::string>("ResolutionFileName");
    fSamplingFileName = pset.get<std::string>("SamplingFileName");
    
    fSaveOutputTree = pset.get<bool>("SaveOutputTree");

    // Make sure we use ifdh to open the beam input file.
    OpenInputFile(fFileName);
    if(fUseDataDriven){
      //std::string found_sampling_file = FindFile(fSamplingFileName);
      //OpenInputFile(found_sampling_file);

      //std::string found_res_file = FindFile(fResolutionFileName);
      //OpenInputFile(found_res_file);

      fSamplingFileName = FindFile(fSamplingFileName);
      OpenInputFile(fSamplingFileName);

      fResolutionFileName = FindFile(fResolutionFileName);
      OpenInputFile(fResolutionFileName);
    }
}



//-----------------------------default destructor----------------------------------
//------------------------------------------------------------------------------------
evgen::ProtoDUNETriggeredBeam::~ProtoDUNETriggeredBeam()
{
    fIFDH->cleanup();   
}

//-------------------------------------------------------------------------------------
void evgen::ProtoDUNETriggeredBeam::beginJob(){

    art::ServiceHandle<art::TFileService> tfs;
    
    TFile *inputFile = TFile::Open(fFileName.c_str());
    // Check we have the file
    if(inputFile == 0x0){
        throw cet::exception("ProtoDUNETriggeredBeam") << "Input file " << fFileName << " cannot be read.\n";
    }
    
    TTree *frontFaceTree = (TTree*)inputFile->Get(fNP04frontTreeName.c_str());
    // Check we have the tree
    if(frontFaceTree == 0x0){
        throw cet::exception("ProtoDUNETriggeredBeam") << "Input tree " << fNP04frontTreeName << " cannot be read.\n";
    }
    std::cout << "All particle tree " << fNP04frontTreeName << " has " << frontFaceTree->GetEntries() << " entries" << std::endl;
   
    // Calculate the number of events to overlay
    CalculateNOverlays();

    // Fill all potential events from the NP04front tree
    fBeamUtils.FillParticleMaps(frontFaceTree, fAllBeamEvents);

    //// Now search for trigger events
    std::vector<int> triggeredEventIDs = fBeamUtils.FindTriggeredEvents(
        inputFile, fTRIG1TreeName, fTRIG2TreeName, fAllBeamEvents);
    std::cout << "Proto trigger list has " << triggeredEventIDs.size() << " events" << std::endl; 

    // For triggered events, we now need to attach the other instrument information
    std::vector<std::string> otherInstrumentTreeNames;
    otherInstrumentTreeNames.push_back(fTOF1TreeName.c_str());
    otherInstrumentTreeNames.push_back(fBPROF1TreeName.c_str());
    otherInstrumentTreeNames.push_back(fBPROF2TreeName.c_str());
    otherInstrumentTreeNames.push_back(fBPROF3TreeName.c_str());
    if (!fIsNP02)
      otherInstrumentTreeNames.push_back(fBPROFEXTTreeName.c_str());
    otherInstrumentTreeNames.push_back(fBPROF4TreeName.c_str());

    for(const std::string &treeName : otherInstrumentTreeNames){ 
      TTree *instrumentTree = (TTree*)inputFile->Get(treeName.c_str());
      fBeamUtils.FillInstrumentInformation(triggeredEventIDs, instrumentTree, fAllBeamEvents);
      std::cout << " - Finished adding information from " << treeName << std::endl;
    }
    std::cout << "Final trigger list has " << triggeredEventIDs.size() << " events" << std::endl; 
    fFinalTriggerEventIDs = triggeredEventIDs;

    // We are done with the input file now
    inputFile->Close();
    delete inputFile;
    inputFile = 0x0;

    // Data-driven file setup
    if(fUseDataDriven){
      fSamplingFile = new TFile(fSamplingFileName.c_str());
      fResolutionFile = new TFile(fResolutionFileName.c_str());
        if (fNominalP =="0.5") {
          // This is the same function as for 1 GeV
          Setup1GeV();
        }
        else if (fNominalP =="1") {
          Setup1GeV();
        }
        else if (fNominalP =="2") {
          // This is the same function as for 1 GeV
          Setup1GeV();
        }
        else if (fNominalP =="3") {
          Setup3GeV();
        }
        else if (fNominalP =="6") {
          Setup6GeV();
        }
        else if (fNominalP =="7") {
          // This is the same function as for 7 GeV
          Setup6GeV();
        }

      Scale2DRes();
      SetMinMax();
    }
    if (fSaveOutputTree) {
      fTriggersGraph = tfs->makeAndRegister<TGraph>("Triggers", fBaseFileName.c_str(), 1);
      fTriggersGraph->SetPoint(0, 0., triggeredEventIDs.size());
      if (fUseDataDriven) {
        fOutputTree = tfs->make<TTree>("tree", "");
        fOutputTree->Branch("PDG", &fOutputPDG);
        fOutputTree->Branch("Event", &fOutputEvent);
        fOutputTree->Branch("Momentum", &fOutputMomentum);
        fOutputTree->Branch("UnsmearedMomentum", &fOutputUnsmearedMomentum);
        fOutputTree->Branch("HUpstream", &fOutputHUpstream);
        fOutputTree->Branch("VUpstream", &fOutputVUpstream);
        fOutputTree->Branch("HDownstream", &fOutputHDownstream);
        fOutputTree->Branch("VDownstream", &fOutputVDownstream);
      }
    }
}

//----------------------------------------------------------------------------------------

void evgen::ProtoDUNETriggeredBeam::beginRun(art::Run& run)
{
    // Grab the geometry object to see what geometry we are using
    art::ServiceHandle<geo::Geometry> geo;
    std::unique_ptr<sumdata::RunData> runcol(new sumdata::RunData(geo->DetectorName()));
    run.put(std::move(runcol), art::fullRun());
}

//--------------------------------------------------------------------------------------------

void evgen::ProtoDUNETriggeredBeam::endJob(){

}


//--------------------------------------------------------------------------------------------
void evgen::ProtoDUNETriggeredBeam::produce(art::Event & e)
{
    if(fEventNumber >= static_cast<int>(fFinalTriggerEventIDs.size())){
        throw cet::exception("ProtoDUNETriggeredBeam") << "Requested entry " << fEventNumber
        << " but tree only has entries 0 to "
        << fFinalTriggerEventIDs.size() - 1 << std::endl;
    }
   
    // Define the truth collection for this event.
    auto truthcol = std::make_unique< std::vector<simb::MCTruth> >();
    
    std::unique_ptr<std::vector<beam::ProtoDUNEBeamEvent> > beamData(new std::vector<beam::ProtoDUNEBeamEvent>);

    simb::MCTruth truth;
    beam::ProtoDUNEBeamEvent beamEvent;
 
    // Group the events together: a triggered event with fOverlay background events
    OverlaidTriggerEvent overlayEvent = GenerateOverlaidEvent(fFinalTriggerEventIDs.at(fEventNumber));

    // Fill the MCTruth object
    fOutputEvent = e.id().event();
    GenerateTrueEvent(truth, overlayEvent, beamEvent);
    
    // Add the MCTruth to the vector
    truthcol->push_back(truth);
    
    // Finally, add the MCTruth to the event
    e.put(std::move(truthcol));

    beamData->push_back( beamEvent );
    e.put( std::move( beamData ) );

    // We have made our event, increment the event number.
    ++fEventNumber;
}

//--------------------------------------------------------------------------------------

// Group the events to overlay a number of background events on each trigger event
OverlaidTriggerEvent evgen::ProtoDUNETriggeredBeam::GenerateOverlaidEvent(const int &trigEventID)
{
  OverlaidTriggerEvent newTriggerEvent(trigEventID);
  // Look to see if any of these neighbouring events had particles
  for(int overlayID = trigEventID - (fOverlays / 2); overlayID < trigEventID + (fOverlays/2); ++overlayID){
    if(fAllBeamEvents.find(overlayID) == fAllBeamEvents.end()) continue;
    
    newTriggerEvent.AddOverlay(overlayID);
  }

  return newTriggerEvent;
}

//-------------------------------------------------------------------------------------------------

void evgen::ProtoDUNETriggeredBeam::GenerateTrueEvent(simb::MCTruth &mcTruth, const OverlaidTriggerEvent &overlayEvent, beam::ProtoDUNEBeamEvent & beamEvent){
 
  // A single particle seems the most accurate description.
  mcTruth.SetOrigin(simb::kSingleParticle);

  // Get the actual triggered event first and the beam particle
  const BeamEvent trigEvent = fAllBeamEvents.at(overlayEvent.fTriggerEventID);

  // We need to be slightly careful here... there are rare events where the pion decays between TRIG2 and NP04front
  BeamParticle trigParticle;
  int primaryStatus = 1; // 1 means track in G4, 0 means don't track
  if(!trigEvent.fHasInteracted){
    trigParticle = trigEvent.fParticlesFront.at(trigEvent.fTriggerID);
  }
  else{
    const std::string trig2Name = fTRIG2TreeName.substr(fTRIG2TreeName.find("/")+1);
    trigParticle = trigEvent.fTriggeredParticleInfo.at(trig2Name);
    primaryStatus = 0;
  }

  std::cout << "- Generating event with trigger particle type " << trigParticle.fPDG << std::endl;

  // Time of the triggered particle (will make all times relative to this)
  const float triggerParticleTime = trigParticle.fPosT;

  // The track ID for primary particles in LArSoft should be negative. This is -1 for our triggered particle
  int trigOutputTrackID = -1*(mcTruth.NParticles() + 1);

  simb::MCParticle triggerParticle;
  if(!fUseDataDriven || trigEvent.fHasInteracted){
    // Create the MCParticle for the triggered beam particle - NB the time offset sets T = 0 for this particle
    triggerParticle = BeamParticleToMCParticle(trigParticle, trigOutputTrackID, triggerParticleTime, primaryStatus, "primary");

    // Fill the ProtoDUNEBeamEvent here to store beamline information
    SetBeamEvent(beamEvent,trigEvent);
    std::cout << "  - Created trigger particle using pure simulation" << std::endl;
    std::cout << "  - Active? " << primaryStatus << std::endl;
    std::cout << "  - Located at " << triggerParticle.EndX() << " " <<
                 triggerParticle.EndY() << " " << triggerParticle.EndZ() <<
                 std::endl;
  }
  else{
    triggerParticle = DataDrivenMCParticle(trigParticle, trigOutputTrackID, triggerParticleTime, beamEvent, primaryStatus, "primary");
    std::cout << "  - Created trigger particle using data driven method" << std::endl;
    std::cout << "  - Located at " << triggerParticle.EndX() << " " <<
                 triggerParticle.EndY() << " " << triggerParticle.EndZ() <<
                 std::endl;
  }

  //mcTruth.Add(triggerParticle);

  std::vector<simb::MCParticle> secondaries;
  std::vector<int> secondary_pdgs;
  // Now we can add any secondaries produced in the interaction before NP04front
  if(trigEvent.fHasInteracted){
    int count = mcTruth.NParticles();
    for(const int &id : trigEvent.fSecondaryTrackIDs){
      trigOutputTrackID = -1*(count + 2);
      BeamParticle secondary = trigEvent.fParticlesFront.at(id);
      simb::MCParticle secondaryParticle = BeamParticleToMCParticle(
          secondary, trigOutputTrackID, triggerParticleTime+secondary.fPosT, 1,
          GetSecondaryProcess(trigParticle.fPDG, secondary.fPDG), triggerParticle.TrackId());
      secondaries.push_back(secondaryParticle);
      triggerParticle.AddDaughter(trigOutputTrackID);
      secondary_pdgs.push_back(secondary.fPDG);
      //mcTruth.Add(secondaryParticle);
      ++count;
    }
  }

  if(!secondaries.empty()){
    std::cout << "  - Trigger particle has daughters:";
    for (int i = 0; i < triggerParticle.NumberDaughters(); ++i) {
      std::cout << " " << triggerParticle.Daughter(i);
    }
    std::cout << std::endl;
  }

  // Add the trigger particle now that the hierarchy has been established
  if (trigEvent.fHasInteracted) {
    triggerParticle.SetEndProcess(
        GetPrimaryEndProcess(trigParticle.fPDG, secondary_pdgs));
  }
  mcTruth.Add(triggerParticle);
  // Now add all of the secondaries (if any)
  for (const simb::MCParticle & sec : secondaries) {
    mcTruth.Add(sec);
    std::cout << "  - Added secondary " << sec.TrackId() <<
                 " of type " << sec.PdgCode() << " with process " <<
                 sec.Process() <<
                 " from interacting primary " << triggerParticle.PdgCode() <<
                 " " << triggerParticle.Mother() << std::endl; 
    std::cout << "  - Located at " << sec.EndX() << " " << 
                 sec.EndY() << " " <<
                 sec.EndZ() << std::endl;
  }

  // Now let's deal with all of the background events
  for(const int &eventID : overlayEvent.fOverlayEventIDs){
    // Each overlay event needs a base time within +/- fBeamWindow of the triggered beam event
    double baseTime = (fFlatRnd.fire() - 0.5)*2.0*(fReadoutWindow*1000.*1000.);
    // Special case for triggered event
    if(overlayEvent.fTriggerEventID == eventID) baseTime = triggerParticleTime;
  
    for (std::pair<int,BeamParticle> element : fAllBeamEvents.at(eventID).fParticlesFront){
      // Don't double count the trigger particle
      if(overlayEvent.fTriggerEventID == eventID && element.first == trigParticle.fTrackID) continue;
      BeamParticle particle = element.second;

      const int outputTrackID =  -1*(mcTruth.NParticles() + 1);
      // For background particles we need to "back-strapolate" them to BPROFEXT so that they can hit the CRT
      SetBackgroundPosition(particle);
      simb::MCParticle backgroundParticle = BeamParticleToMCParticle(particle,outputTrackID,baseTime,1,"primaryBackground");
      mcTruth.Add(backgroundParticle);
    }  

  }

  std::cout << "Created event with " << mcTruth.NParticles() << " particles." << std::endl;
}

//---------------------------------------------------------------------------------------

simb::MCParticle evgen::ProtoDUNETriggeredBeam::BeamParticleToMCParticle(
    const BeamParticle &beamParticle, const int outputTrackID,
    const float timeOffset, const int primaryStatus, const std::string process,
    const int motherID){

  simb::MCParticle newParticle(outputTrackID,beamParticle.fPDG,process, motherID, -1.0, primaryStatus);

  // Get the position four-vector
  const TLorentzVector pos(beamParticle.fPosX,beamParticle.fPosY,beamParticle.fPosZ,beamParticle.fPosT - timeOffset);

  // Get the mass to calculate the momentum four-vector
  const TDatabasePDG* databasePDG = TDatabasePDG::Instance();
  const TParticlePDG* definition = databasePDG->GetParticle(beamParticle.fPDG);
  const float mass = definition->Mass();
  const float energy = sqrt(mass*mass + TVector3(beamParticle.fMomX,beamParticle.fMomY,beamParticle.fMomZ).Mag2());

  const TLorentzVector mom(beamParticle.fMomX,beamParticle.fMomY,beamParticle.fMomZ,energy);

  // Add the single trajectory point to the MCParticle
  newParticle.AddTrajectoryPoint(pos,mom);
  return newParticle;
}

//---------------------------------------------------------------------------------------

simb::MCParticle evgen::ProtoDUNETriggeredBeam::DataDrivenMCParticle(
    const BeamParticle &beamParticle, const int outputTrackID,
    const float timeOffset, beam::ProtoDUNEBeamEvent & beamEvent, const int primaryStatus, const std::string process) {
  
  const int pdg = (fIncludeAnti ? beamParticle.fPDG : abs(beamParticle.fPDG));
  simb::MCParticle newParticle(outputTrackID, pdg, process, -1, -1.0, primaryStatus);
  
  double kin_samples[5]; //the point in phase space to check against pdf
  double pdf_check; //the number used for the checking
  bool sample_again = true;

  double sampled_momentum = 0.;
  double sampled_h_upstream = 0.;
  double sampled_v_upstream = 0.;
  double sampled_h_downstream = 0.;
  double sampled_v_downstream = 0.;
  int nSamples = 0;
  while (sample_again) {
    /*
    if (nSamples > fMaxSamples) {
      throw cet::exception("ProtoDUNETriggeredBeam") << 
          "Reached max samples. Exiting" << std::endl;
    }*/
    fRNG.RndmArray(5, &kin_samples[0]);
    pdf_check = fRNG.Rndm();

    //Need to convert the numbers sampled for the kinematics (0, 1)
    //to within the sampling range
    double kin_point[5];
    //Convert(kin_samples, minima, maxima, kin_point);
    ConvertSamplingPoint(kin_samples, fMinima, fMaxima, kin_point);


    //Find the bin in the THnSparseD. If the bin has a value of 0,
    //then it would not have been allocated to save on memory.
    //The false parameter prevents that bin from being allocated here,
    //to save memory
    const long long bin = fPDFs.at(fPDGToName.at(pdg))->GetBin(&kin_point[0],false);
    //The bin has no chance of being populated, move on
    if (bin == -1) continue;

    //Find how likely we are to populate this bin
    const double pdf_value = fPDFs.at(fPDGToName.at(pdg))->GetBinContent(bin);

    //If successful, save info and move on
    if (pdf_check <= pdf_value) {
      if (fVerbose) {
        std::cout << "bin: " << bin << " PDF val: " << pdf_value <<
                     " Check: " << pdf_check << std::endl;
        std::cout << kin_samples[0] << " " << kin_samples[1] << " " <<
                     kin_samples[2] << " " << kin_samples[3] << " " <<
                     kin_samples[4] << std::endl;
        std::cout << kin_point[0] << " " << kin_point[1] << " " <<
                     kin_point[2] << " " << kin_point[3] << " " <<
                     kin_point[4] << std::endl;
        std::cout << "Will keep" << std::endl;
      }

      //diff
      sampled_momentum = kin_point[0];
      sampled_v_upstream = kin_point[1];
      sampled_h_upstream = kin_point[2];
      sampled_v_downstream = kin_point[3];
      sampled_h_downstream = kin_point[4];

      sample_again = false;
    }
    ++nSamples;
  }

  TLorentzVector position(0, 0, 0, 0);
  TLorentzVector momentum(0., 0., 0., 0.);
  SetDataDrivenPosMom(position, momentum, sampled_h_upstream,
                      sampled_v_upstream, sampled_h_downstream,
                      sampled_v_downstream, sampled_momentum,
                      pdg);
  newParticle.AddTrajectoryPoint(position, momentum);

  SetDataDrivenBeamEvent(beamEvent, sampled_h_upstream,
                      sampled_v_upstream, sampled_h_downstream,
                      sampled_v_downstream, sampled_momentum);

  if (fSaveOutputTree) {
    fOutputPDG = pdg;
    fOutputMomentum = sampled_momentum;
    fOutputHUpstream = sampled_h_upstream;
    fOutputVUpstream = sampled_v_upstream;
    fOutputHDownstream = sampled_h_downstream;
    fOutputVDownstream = sampled_v_downstream;
    fOutputTree->Fill();
  }

  return newParticle;
}

//------------------------------------------------------------------------------------


void evgen::ProtoDUNETriggeredBeam::ConvertSamplingPoint(
    double input_point[5], std::vector<double> minima,
    std::vector<double> maxima, double output_point[5]) {
  for (int i = 0; i < 5; ++i) {
    const double delta = maxima[i] - minima[i];
    output_point[i] = minima[i] + delta * input_point[i];
  }
}

void evgen::ProtoDUNETriggeredBeam::SetDataDrivenPosMom(
    TLorentzVector & position, TLorentzVector & momentum, double sampledHUp,
    double sampledVUp, double sampledHDown, double sampledVDown,
    double sampledMomentum, int beamPDG) {

  const double upstreamX = 96. - sampledHUp; 
  const double upstreamY = 96. - sampledVUp;
  const double downstreamX = 96. - sampledHDown;
  const double downstreamY = 96. - sampledVDown;


  TVector3 upstream_point = fBeamUtils.ConvertProfCoordinates(upstreamX, upstreamY, 0.,
                                                   fBPROFEXTPos);
  TVector3 downstream_point = fBeamUtils.ConvertProfCoordinates(downstreamX, downstreamY, 0.,
                                                     fBPROF4Pos);
  TVector3 dR = (downstream_point - upstream_point).Unit();

  //Project to generator point
  double deltaZ = (fBeamZ - downstream_point.Z());
  double deltaX = (dR.X() / dR.Z()) * deltaZ;
  double deltaY = (dR.Y() / dR.Z()) * deltaZ;

  TVector3 generator_point = downstream_point +
                             TVector3(deltaX, deltaY, deltaZ);
  //Set the position 4-vector
  //Time = 0 for now?
  position = TLorentzVector(generator_point, 0.);

  //Prints out the projected position at the face of the TPC
  if (fVerbose) {
    deltaZ = (-1.*fBeamZ);
    deltaX = (dR.X() / dR.Z()) * deltaZ;
    deltaY = (dR.Y() / dR.Z()) * deltaZ;

    TVector3 last_point = generator_point +
                          TVector3(deltaX, deltaY, deltaZ);

    std::cout << last_point.X() << " " << last_point.Y() << " " <<
                 last_point.Z() << std::endl;
  }

  double unsmeared_momentum = 0.;
  /*switch (fUnsmearType) {
    case 1:
      unsmeared_momentum = UnsmearMomentum1D(sampledMomentum, beamPDG);
      break;
    case 2:*/
  unsmeared_momentum = UnsmearMomentum2D(sampledMomentum, beamPDG);
      //GetSystWeights();
      /*break;
    default:
      //Just do 1D
      unsmeared_momentum = UnsmearMomentum1D(sampledMomentum, beamPDG);
      break;
  }*/

  //TVector3 mom_vec = fRandMomentum[fCurrentEvent]*dR;
  //TVector3 mom_vec = unsmeared_momentum*dR;
  const TVector3 mom_vec = unsmeared_momentum*dR;
  fOutputUnsmearedMomentum = unsmeared_momentum;

  //Get the PDG and set the mass & energy accordingly
  const TDatabasePDG * dbPDG = TDatabasePDG::Instance();
  const TParticlePDG * def = dbPDG->GetParticle(beamPDG);
  const double mass = def->Mass();
  const double energy = sqrt(mass*mass + mom_vec.Mag2());

  //Set the momentum 4-vector
  momentum = TLorentzVector(mom_vec, energy);
}

double evgen::ProtoDUNETriggeredBeam::UnsmearMomentum2D(double momentum, int pdg) {

  if (fVerbose) {
    std::cout << "Using 2D Unsmear method" << std::endl;
  }

  TH2D * res = fResolutionHists2D.at(fPDGToName.at(pdg));

  const int xBin = res->GetXaxis()->FindBin(momentum);
  if (fVerbose) {
    std::cout << "Momentum & bin: " << momentum << " " <<
                 xBin << std::endl;
  }

  double true_min = res->GetYaxis()->GetXmin();
  double true_max = res->GetYaxis()->GetXmax();
  for (int i = 1; i <= res->GetNbinsY(); ++i) {
    if (res->GetBinContent(xBin, i) > 0.) {
      true_min = res->GetYaxis()->GetBinLowEdge(i);
      break;
    }
  }
  for (int i = res->GetNbinsY(); i >= 1; --i) {
    if (res->GetBinContent(xBin, i) > 0.) {
      true_max = res->GetYaxis()->GetBinUpEdge(i);
      break;
    }
  }

  if (fVerbose)
    std::cout << "True min and max: " << true_min << " " << true_max << std::endl;
  
  double unsmeared_momentum = 0.;
  while (true) {
    const double t = fRNG.Uniform(true_min, true_max);
    const double pdf_check = fRNG.Rndm(); //random number to check against PDF 
    
    const int yBin = res->GetYaxis()->FindBin(t);
    const double pdf_value = res->GetBinContent(xBin, yBin);
    if (fVerbose) {
      std::cout << "True mom & bin: " << t << " " << yBin << std::endl;
      std::cout << "Check & val: " << pdf_check << " " << pdf_value <<
                   std::endl;
    }
    if (pdf_check < pdf_value) {
      unsmeared_momentum = t;
      if (fVerbose) std::cout << "Setting momentum to " << t << std::endl;
      break;
    }
  }

  return unsmeared_momentum;
}

std::string evgen::ProtoDUNETriggeredBeam::GetPrimaryEndProcess(
    const int &primary_pdg, const std::vector<int> &secondary_pdgs) {
  
  if (primary_pdg == 2212) {
    return "protonInelastic";
  }
  else if (primary_pdg == 211) {
    if (std::find(secondary_pdgs.begin(), secondary_pdgs.end(), -13) !=
        secondary_pdgs.end()) {
      return "Decay";
    }
    else {
      return "pi+Inelastic";
    }
  }
  else if (primary_pdg == -211) {
    if (std::find(secondary_pdgs.begin(), secondary_pdgs.end(), 13) !=
        secondary_pdgs.end()) {
      return "Decay";
    }
    else {
      return "pi-Inelastic";
    }
  }
  else if (primary_pdg == 321) {
    return "Decay";
  }

  return "default";
}

std::string evgen::ProtoDUNETriggeredBeam::GetSecondaryProcess(
    const int &primary_pdg, const int &secondary_pdg) {
  
  std::string preamble = "primary:";
  if (primary_pdg == 2212) {
    return preamble + "protonInelastic";
  }
  else if (primary_pdg == 211) {
    if (secondary_pdg == -13) {
      return preamble + "Decay";
    }
    else if (secondary_pdg == 211 || secondary_pdg == -211 ||
            secondary_pdg == 2212 || secondary_pdg == 2112 ||
            secondary_pdg > 2212 || secondary_pdg == 22) {
      return preamble + "pi+Inelastic";
    }
  }
  else if (primary_pdg == -211) {
    if (secondary_pdg == 13) {
      return preamble + "Decay";
    }
    else if (secondary_pdg == 211 || secondary_pdg == -211 ||
            secondary_pdg == 2212 || secondary_pdg == 2112 ||
            secondary_pdg > 2212 || secondary_pdg == 22) {
      return preamble + "pi-Inelastic";
    }
  }
  else if (primary_pdg == 321) {
    return preamble + "Decay";
  }

  std::cout << "Notice! Unknown secondary option " << primary_pdg << " " <<
               secondary_pdg << std::endl;
  return preamble + "default";
}

void evgen::ProtoDUNETriggeredBeam::SetMinMax() {
  if (fNominalP =="0.5") {
    fMinima[0] = 0.3;
    fMaxima[0] = 0.7;
  }
  else if (fNominalP =="2") {
    fMinima[0] = 1.6;
    fMaxima[0] = 2.4;
  }
  else if (fNominalP =="3") {
    fMinima[0] = 2.4;
    fMaxima[0] = 3.6;
  }
  else if (fNominalP =="6") {
    fMinima[0] = 5.0;
    fMaxima[0] = 7.0;
  }
  else if (fNominalP =="7") {
    fMinima[0] = 6.0;
    fMaxima[0] = 8.0;
  }
}

void evgen::ProtoDUNETriggeredBeam::Scale2DRes() {
  for (auto it = fResolutionHists2D.begin();
       it != fResolutionHists2D.end(); ++it) {
    TH2D * this_hist = it->second;
    for (int i = 1; i <= this_hist->GetNbinsX(); ++i) {
      const double integral = this_hist->TH1::Integral(i, i);
      // double total = 0.; // unused
      for (int j = 1; j <= this_hist->GetNbinsY(); ++j) {
        this_hist->SetBinContent(i, j,
            this_hist->GetBinContent(i, j) / integral);
        // total += this_hist->GetBinContent(i, j); // unused
      }
    }
  }
}

void evgen::ProtoDUNETriggeredBeam::Setup1GeV() {
  std::vector<std::string> particle_types = {
    "Muons", "Pions", "Protons", "Electrons"
  };
  for (size_t i = 0; i < particle_types.size(); ++i) {
    const std::string part_type = particle_types[i];
    if (part_type == "Muons") {
      fPDFs[part_type] = (THnSparseD*)fSamplingFile->Get("Pions"); 
    }
    else {
      fPDFs[part_type] = (THnSparseD*)fSamplingFile->Get(part_type.c_str());
    }

    //Also get the resolutions
    std::string res_name = "";
    if (part_type == "Muons") {
      res_name = "hPionsRes";
    }
    else {
      res_name = "h" + part_type + "Res";
    }

    res_name += "2D";
    fResolutionHists2D[part_type] = (TH2D*)fResolutionFile->Get(res_name.c_str());

  }
}

void evgen::ProtoDUNETriggeredBeam::Setup3GeV() {
  std::vector<std::string> particle_types = {
    "Muons", "Pions", "Protons", "Electrons", "Kaons"
  };

  for (size_t i = 0; i < particle_types.size(); ++i) {
    const std::string part_type = particle_types[i];
    if (part_type == "Muons") {
      fPDFs[part_type] = (THnSparseD*)fSamplingFile->Get("Pions"); 
    }
    else if (part_type == "Kaons") {
      fPDFs[part_type] = (THnSparseD*)fSamplingFile->Get("Protons"); 
    }
    else {
      fPDFs[part_type] = (THnSparseD*)fSamplingFile->Get(part_type.c_str());
    }

    //Also get the resolutions
    std::string res_name = "";
    if (part_type == "Muons") {
      res_name = "hPionsRes";
    }
    /*
    else if (part_type == "Kaons") {
      res_name = "hProtonsRes";
    }*/
    else {
      res_name = "h" + part_type + "Res";
    }
    
    //fResolutionHists[part_type] = (TH1D*)fResolutionFile->Get(res_name.c_str());

    res_name += "2D";
    fResolutionHists2D[part_type] = (TH2D*)fResolutionFile->Get(res_name.c_str());

    /*
    std::string plus_name = res_name + "Plus";
    fResolutionHists2DPlus[part_type] = (TH2D*)fResolutionFile->Get(plus_name.c_str());

    std::string minus_name = res_name + "Minus";
    fResolutionHists2DMinus[part_type] = (TH2D*)fResolutionFile->Get(minus_name.c_str());
    */
  }
}

void evgen::ProtoDUNETriggeredBeam::Setup6GeV() {
  std::vector<std::string> particle_types = {
    "Muons", "Pions", "Protons", "Electrons", "Kaons"
  };

  for (size_t i = 0; i < particle_types.size(); ++i) {
    const std::string part_type = particle_types[i];
    if (part_type == "Muons" || part_type == "Electrons") {
      fPDFs[part_type] = (THnSparseD*)fSamplingFile->Get("Pions"); 
    }
    else {
      fPDFs[part_type] = (THnSparseD*)fSamplingFile->Get(part_type.c_str());
    }

    //Also get the resolutions
    std::string res_name = "";
    if (part_type == "Muons") {
      res_name = "hPionsRes";
    }
    else {
      res_name = "h" + part_type + "Res";
    }

    //fResolutionHists[part_type] = (TH1D*)fResolutionFile->Get(res_name.c_str());

    res_name += "2D";
    fResolutionHists2D[part_type] = (TH2D*)fResolutionFile->Get(res_name.c_str());

    /*
    std::string plus_name = res_name + "Plus";
    fResolutionHists2DPlus[part_type] = (TH2D*)fResolutionFile->Get(plus_name.c_str());

    std::string minus_name = res_name + "Minus";
    fResolutionHists2DMinus[part_type] = (TH2D*)fResolutionFile->Get(minus_name.c_str());
    */
  }
}

void evgen::ProtoDUNETriggeredBeam::SetDataDrivenBeamEvent(
    beam::ProtoDUNEBeamEvent & beamEvent,
    double sampledHUp, double sampledVUp, double sampledHDown,
    double sampledVDown, double sampledMomentum) {

  beamEvent.SetTOFs(std::vector<double>{0.});
  beamEvent.SetTOFChans(std::vector<int>{0});
  beamEvent.SetUpstreamTriggers(std::vector<size_t>{0});
  beamEvent.SetDownstreamTriggers(std::vector<size_t>{0});
  beamEvent.SetCalibrations(0., 0., 0., 0.);
  beamEvent.DecodeTOF();

  beamEvent.SetMagnetCurrent(0.);
  beamEvent.SetTimingTrigger(12);

  beam::CKov dummy;
  dummy.trigger = 0;
  dummy.pressure = 0.;
  dummy.timeStamp = 0.;
  beamEvent.SetCKov0(dummy);
  beamEvent.SetCKov1(dummy);

  beamEvent.SetActiveTrigger(0);
  beamEvent.SetT0(std::make_pair(0.,0.));

  //Dummy positions for these
  beamEvent.SetFBMTrigger("XBPF022697", MakeFiberMonitor(.5));
  beamEvent.SetFBMTrigger("XBPF022698", MakeFiberMonitor(.5));
  beamEvent.SetFBMTrigger("XBPF022701", MakeFiberMonitor(.5));
  beamEvent.SetFBMTrigger("XBPF022702", MakeFiberMonitor(.5));

  const double upstream_x = sampledHUp;
  const double upstream_y = sampledVUp;
  const double downstream_x = sampledHDown;
  const double downstream_y = sampledVDown;

  beamEvent.SetFBMTrigger("XBPF022707", MakeFiberMonitor(96. - upstream_x));//X
  beamEvent.SetFBMTrigger("XBPF022708", MakeFiberMonitor(96. - upstream_y));//Y

  beamEvent.SetFBMTrigger("XBPF022716", MakeFiberMonitor(96. - downstream_x));//X
  beamEvent.SetFBMTrigger("XBPF022717", MakeFiberMonitor(96. - downstream_y));//Y

  MakeTracks(beamEvent);

  beamEvent.AddRecoBeamMomentum(sampledMomentum);
}

// Function written in similar way as "openDBs()" in CORSIKAGen_module.cc
void evgen::ProtoDUNETriggeredBeam::OpenInputFile(std::string & filename)
{

    if (fStreamInput) {
      if (fFileName.find("/pnfs") != 0) {
        throw cet::exception("ProtoDUNETriggeredBeam") << "Filename " <<
            fFileName << " does not start with /pnfs as required for streaming" << std::endl;
      }
      filename.replace(0, 5, "root://fndca1.fnal.gov:1094//pnfs/fnal.gov/usr");
      return;
    }

    // Setup ifdh object
    if (!fIFDH)
    {
        fIFDH = new ifdh_ns::ifdh;
    }
    
    const char* ifdh_debug_env = std::getenv("IFDH_DEBUG_LEVEL");
    if ( ifdh_debug_env )
    {
        mf::LogInfo("ProtoDUNETriggeredBeam") << "IFDH_DEBUG_LEVEL: " << ifdh_debug_env<<"\n";
        fIFDH->set_debug(ifdh_debug_env);
    }
    
    const std::string path(gSystem->DirName(filename.c_str()));
    const std::string pattern(gSystem->BaseName(filename.c_str()));
    
    auto const flist = fIFDH->findMatchingFiles(path,pattern);
    if (flist.empty())
    {
        struct stat buffer;
        if (stat(filename.c_str(), &buffer) != 0)
        {
            throw cet::exception("ProtoDUNETriggeredBeam") << "No files returned for path:pattern: "<<path<<":"<<pattern<<std::endl;
        }
        else
        {
            mf::LogInfo("ProtoDUNETriggeredBeam") << "For "<< filename <<"\n";
        }
    }
    else
    {
        std::pair<std::string, long> f = flist.front();
        
        mf::LogInfo("ProtoDUNETriggeredBeam") << "For "<< filename <<"\n";
        
        // Do the fetching, store local filepaths in locallist
        
        mf::LogInfo("ProtoDUNETriggeredBeam")
        << "Fetching: " << f.first << " " << f.second <<"\n";
        std::string fetchedfile(fIFDH->fetchInput(f.first));
        MF_LOG_DEBUG("ProtoDUNETriggeredBeam") << " Fetched; local path: " << fetchedfile;
        
        filename = fetchedfile;
    }
}


//----------------------------------------------------------------------------------

void evgen::ProtoDUNETriggeredBeam::CalculateNOverlays(){
    
    // The number of events to overlay is as follows:
    // N = Intensity * 2.0 * ReadoutWindow / BeamSpillLength
    fOverlays = fIntensity * (2.0 * fReadoutWindow / 1000.) / fBeamSpillLength;
    std::cout << "Number of overlays = " << fOverlays << std::endl;   
}
 
//----------------------------------------------------------------------------------

TVector3 evgen::ProtoDUNETriggeredBeam::ConvertBeamMonitorMomentumVec(float px, float py, float pz){

  TVector3 newMom(px,py,pz);
  RotateMonitorVector(newMom);
  return newMom;
}
 
//----------------------------------------------------------------------------------

void evgen::ProtoDUNETriggeredBeam::BeamMonitorBasisVectors(){

  fBMBasisX = TVector3(1.,0.,0.);
  fBMBasisY = TVector3(0.,1.,0.);
  fBMBasisZ = TVector3(0.,0.,1.);
  RotateMonitorVector(fBMBasisX);
  RotateMonitorVector(fBMBasisY);
  RotateMonitorVector(fBMBasisZ);

}
 
//----------------------------------------------------------------------------------

void evgen::ProtoDUNETriggeredBeam::RotateMonitorVector(TVector3 &vec){

  // Note: reordering how these are done in order to keep the basis
  //       vectors of the monitors parallel to the ground. 
  vec.RotateX( fRotateMonitorYZ * TMath::Pi() / 180. );
  vec.RotateY( fRotateMonitorXZ * TMath::Pi() / 180. );

}
 
//----------------------------------------------------------------------------------
//NP02 needs something different
void evgen::ProtoDUNETriggeredBeam::SetBackgroundPosition(BeamParticle &particle){

  const TVector3 pos(particle.fPosX,particle.fPosY,particle.fPosZ);
  const TVector3 dir = TVector3(particle.fMomX,particle.fMomY,particle.fMomZ).Unit();

  // Want to move the position upstream by a distance equal to fNP04frontPos - fBPROFEXTPos
  // This length is in the beam direction frame unless we account for it
  // Convert the instrument positions from mm to cm
  const float shiftLength = (fNP04frontPos - fBPROFEXTPos)/(10.0*fBMBasisZ.Z());

  const TVector3 shiftedPos = pos - shiftLength*dir;

  particle.fPosX = shiftedPos.X();
  particle.fPosY = shiftedPos.Y();
  particle.fPosZ = shiftedPos.Z();
}
 
//----------------------------------------------------------------------------------

void evgen::ProtoDUNETriggeredBeam::SetBeamEvent(beam::ProtoDUNEBeamEvent & beamevt, const BeamEvent &triggerEvent){

  // Instrument names
  const std::string tof1Name     = fTOF1TreeName.substr(fTOF1TreeName.find("/")+1);
  const std::string bprof1Name   = fBPROF1TreeName.substr(fBPROF1TreeName.find("/")+1);
  const std::string bprof2Name   = fBPROF2TreeName.substr(fBPROF2TreeName.find("/")+1);
  const std::string bprof3Name   = fBPROF3TreeName.substr(fBPROF3TreeName.find("/")+1);
  const std::string trig1Name    = fTRIG1TreeName.substr(fTRIG1TreeName.find("/")+1);
  const std::string bprof4Name   = fBPROF4TreeName.substr(fBPROF4TreeName.find("/")+1);
  const std::string trig2Name    = fTRIG2TreeName.substr(fTRIG2TreeName.find("/")+1);

  // TOF first
  const float trig2Time = triggerEvent.fTriggeredParticleInfo.at(trig2Name).fPosT;
  const float tof1Time  = triggerEvent.fTriggeredParticleInfo.at(tof1Name).fPosT;
  beamevt.SetTOFs(std::vector<double>{trig2Time - tof1Time});
  beamevt.SetTOFChans( std::vector<int>{ 0 } );
  beamevt.SetUpstreamTriggers( std::vector<size_t>{0} );
  beamevt.SetDownstreamTriggers( std::vector<size_t>{0} );
  beamevt.SetCalibrations( 0., 0., 0., 0. );
  beamevt.DecodeTOF();

  //NP02 -- Get the correct names

  // Fibre monitors
  const BeamParticle &bprof1Particle = triggerEvent.fTriggeredParticleInfo.at(bprof1Name);
  const BeamParticle &bprof2Particle = triggerEvent.fTriggeredParticleInfo.at(bprof2Name);
  const BeamParticle &bprof3Particle = triggerEvent.fTriggeredParticleInfo.at(bprof3Name);
  const BeamParticle &bprof4Particle = triggerEvent.fTriggeredParticleInfo.at(bprof4Name);
  // (x,y) for BPROF1
  beamevt.SetFBMTrigger( DetNameBProf1X/*"XBPF022697"*/, MakeFiberMonitor( bprof1Particle.fPosX ) );
  if (!fIsNP02)
    beamevt.SetFBMTrigger( DetNameBProf1Y/*"XBPF022698"*/, MakeFiberMonitor( bprof1Particle.fPosY ) );
  // Just x for BPROF2 and BPROF3
  beamevt.SetFBMTrigger( DetNameBProf2/*"XBPF022701"*/, MakeFiberMonitor( bprof2Particle.fPosX ) );
  beamevt.SetFBMTrigger( DetNameBProf3/*"XBPF022702"*/, MakeFiberMonitor( bprof3Particle.fPosX ) );
  if (!fIsNP02) {
    // (x,y) for BPROFEXT
    const std::string bprofEXTName = fBPROFEXTTreeName.substr(fBPROFEXTTreeName.find("/")+1);
    const BeamParticle &bprofExtParticle = triggerEvent.fTriggeredParticleInfo.at(bprofEXTName);
    beamevt.SetFBMTrigger( DetNameBProfExtX/*"XBPF022707"*/, MakeFiberMonitor( bprofExtParticle.fPosX ) );
    beamevt.SetFBMTrigger( DetNameBProfExtY/*"XBPF022708"*/, MakeFiberMonitor( bprofExtParticle.fPosY ) );
  }
  // (x,y) for BPROF4
  beamevt.SetFBMTrigger( DetNameBProf4X/*"XBPF022716"*/, MakeFiberMonitor( bprof4Particle.fPosX ) );
  if (!fIsNP02)
    beamevt.SetFBMTrigger( DetNameBProf4Y/*"XBPF022717"*/, MakeFiberMonitor( bprof4Particle.fPosY ) );

  // Cherenkovs aren't simulated, so set to dummy values
  beam::CKov dummy;
  dummy.trigger = 0;
  dummy.pressure = 0.;
  dummy.timeStamp = 0.;
  beamevt.SetCKov0( dummy );
  beamevt.SetCKov1( dummy );

  // Trigger information
  beamevt.SetMagnetCurrent( 0. );
  beamevt.SetTimingTrigger( 12 );
  beamevt.SetActiveTrigger(0);
  beamevt.SetT0( std::make_pair(0.,0.) );
 
  // Do the beamline instrumentation reconstruction
  if (!fIsNP02)
    MakeTracks( beamevt );
  MomentumSpectrometer( beamevt );
}
 
//----------------------------------------------------------------------------------

beam::FBM evgen::ProtoDUNETriggeredBeam::MakeFiberMonitor( float pos ){
  beam::FBM theFBM;

  //I should probably just make this into
  //a constructor for the FBM...
  theFBM.ID = -1;
  theFBM.glitch_mask = {};
  std::uninitialized_fill( std::begin(theFBM.fiberData), std::end(theFBM.fiberData), 0. );
  std::uninitialized_fill( std::begin(theFBM.timeData), std::end(theFBM.timeData), 0. );
  theFBM.timeStamp = 0.;

  const short f = 96 -  short( floor(pos) ) - 1;
  theFBM.fibers[f] = 1;
  theFBM.active.push_back(f);
  theFBM.decoded = true;

  return theFBM; 
}
 
//----------------------------------------------------------------------------------

double evgen::ProtoDUNETriggeredBeam::GetPosition( short fiber ){
  return ((96 - fiber) - .5);
}
 
//----------------------------------------------------------------------------------

void evgen::ProtoDUNETriggeredBeam::MakeTracks( beam::ProtoDUNEBeamEvent & beamEvent ){
  
  //We should only have one active fiber at a time
  //
  //Might need to ask Leigh, etc. if it's possible
  //to have multiple particles going through at the
  //same time. In which case -- try to implement it
  
  const short fx1 = beamEvent.GetFBM( "XBPF022707" ).active[0];
  const short fy1 = beamEvent.GetFBM( "XBPF022708" ).active[0];

  const double x1 = GetPosition( fx1 );
  const double y1 = GetPosition( fy1 );

  TVector3 pos1 = fBeamUtils.ConvertProfCoordinates( x1, y1, 0., fBPROFEXTPos );

  const short fx2 = beamEvent.GetFBM( "XBPF022716" ).active[0];
  const short fy2 = beamEvent.GetFBM( "XBPF022717" ).active[0];

  const double x2 = GetPosition( fx2 );
  const double y2 = GetPosition( fy2 );

  TVector3 pos2 = fBeamUtils.ConvertProfCoordinates( x2, y2, 0., fBPROF4Pos );
 
  std::vector< TVector3 > thePoints = { pos1, pos2, ProjectToTPC( pos1, pos2 ) };
  std::vector< TVector3 > theMomenta = {
    ( pos2 - pos1 ).Unit(),
    ( pos2 - pos1 ).Unit(),
    ( pos2 - pos1 ).Unit()
  };

  beamEvent.AddBeamTrack(
    recob::Track(
      recob::TrackTrajectory(recob::tracking::convertCollToPoint( thePoints ),
                             recob::tracking::convertCollToVector( theMomenta ),
                             recob::Track::Flags_t( thePoints.size() ),
                             false ),
      0, -1., 0, recob::tracking::SMatrixSym55(), recob::tracking::SMatrixSym55(), 1 
    )
  );
    
}
 
//----------------------------------------------------------------------------------

TVector3 evgen::ProtoDUNETriggeredBeam::ProjectToTPC(TVector3 firstPoint, TVector3 secondPoint){
  const TVector3 dR = (secondPoint - firstPoint);
  
  const double deltaZ = -1.*secondPoint.Z();
  const double deltaX = deltaZ * (dR.X() / dR.Z());
  const double deltaY = deltaZ * (dR.Y() / dR.Z());

  TVector3 lastPoint = secondPoint + TVector3(deltaX, deltaY, deltaZ);
  return lastPoint;
}
 
//----------------------------------------------------------------------------------

void evgen::ProtoDUNETriggeredBeam::MomentumSpectrometer( beam::ProtoDUNEBeamEvent & beamEvent ){

  const short f1 = beamEvent.GetFBM( DetNameBProf1X/*"XBPF022697"*/ ).active[0];
  const short f2 = beamEvent.GetFBM( DetNameBProf2/*"XBPF022701"*/ ).active[0];
  const short f3 = beamEvent.GetFBM( DetNameBProf3/*"XBPF022702"*/ ).active[0];

  const double x1 = -1.e-3 * GetPosition( f1 );
  const double x2 = -1.e-3 * GetPosition( f2 );
  const double x3 = -1.e-3 * GetPosition( f3 );

  const double cos_theta = MomentumCosTheta( x1, x2, x3 );
  const double momentum = 299792458.0*fLB/(1.E9 * acos(cos_theta));
  beamEvent.AddRecoBeamMomentum( momentum );

}
 
//----------------------------------------------------------------------------------

double evgen::ProtoDUNETriggeredBeam::MomentumCosTheta(double x1, double x2, double x3){
  const double a =  (x2*fL3 - x3*fL2)*cos(fBeamBend)/(fL3-fL2);
 
  const double numTerm = (a - x1)*( (fL3 - fL2)*tan(fBeamBend) + (x3 - x2)*cos(fBeamBend) ) + fL1*( fL3 - fL2 );

  const double denomTerm1 = sqrt( fL1*fL1 + (a - x1)*(a - x1) );
  const double denomTerm2 = sqrt( TMath::Power( ( (fL3 - fL2)*tan(fBeamBend) + (x3 - x2)*cos(fBeamBend) ),2)
                   + TMath::Power( ( (fL3 - fL2) ),2) );
  const double denom = denomTerm1 * denomTerm2;

  const double cosTheta = numTerm/denom;  
  return cosTheta;
}


std::string evgen::ProtoDUNETriggeredBeam::FindFile(const std::string filename) {
  mf::LogInfo("evgen::ProtoDUNETriggeredBeam::FindFile") << "Searching for " << filename;
  if (cet::file_exists(filename)) {
    mf::LogInfo("evgen::ProtoDUNETriggeredBeam::FindFile") << "File exists. Opening " << filename;
    return filename;
  }
  else {
    mf::LogInfo("evgen::ProtoDUNETriggeredBeam::FindFile") << "File does not exist here. Searching FW_SEARCH_PATH";
    cet::search_path sp{"FW_SEARCH_PATH"};
    std::string found_filename;
    auto found = sp.find_file(filename, found_filename);
    if (!found) {
      throw cet::exception("ProtoDUNECalibration.cxx") << "Could not find " << filename;
    }

    mf::LogInfo("evgen::ProtoDUNETriggeredBeam::FindFile") << "Found file " << found_filename;
    return found_filename;
  }
}


DEFINE_ART_MODULE(evgen::ProtoDUNETriggeredBeam)

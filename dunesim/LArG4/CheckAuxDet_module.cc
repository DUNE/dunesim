////////////////////////////////////////////////////////////////////////
// Class:       CheckAuxDet
// Module Type: analyzer
// File:        CheckAuxDet_module.cc
//
// Generated at Tue Jan  6 22:27:12 2015 by Tingjun Yang using artmod
// from cetpkgsupport v1_07_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h" 
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "lardataobj/Simulation/AuxDetSimChannel.h"
#include "TTree.h"
#include <iostream>

constexpr unsigned short kMaxAuxDets = 100;
constexpr unsigned short kMaxTkIDs = 100;

namespace dune {
  class CheckAuxDet;
}

class dune::CheckAuxDet : public art::EDAnalyzer {
public:
  explicit CheckAuxDet(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CheckAuxDet(CheckAuxDet const &) = delete;
  CheckAuxDet(CheckAuxDet &&) = delete;
  CheckAuxDet & operator = (CheckAuxDet const &) = delete;
  CheckAuxDet & operator = (CheckAuxDet &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void reconfigure(fhicl::ParameterSet const & p) ;

private:

  // Declare member data here.
  std::string fLArG4ModuleLabel;
  TTree *fTree;
  //run information
  int run;
  int subrun;
  int event;
  int nauxdets;
  int auxdetid[kMaxAuxDets];
  int ntrkids[kMaxAuxDets];
  float entryx[kMaxAuxDets][kMaxTkIDs];
  float entryy[kMaxAuxDets][kMaxTkIDs];
  float entryz[kMaxAuxDets][kMaxTkIDs];
  float entryt[kMaxAuxDets][kMaxTkIDs];
  float exitx[kMaxAuxDets][kMaxTkIDs];
  float exity[kMaxAuxDets][kMaxTkIDs];
  float exitz[kMaxAuxDets][kMaxTkIDs];
  float exitt[kMaxAuxDets][kMaxTkIDs];
  float exitpx[kMaxAuxDets][kMaxTkIDs];
  float exitpy[kMaxAuxDets][kMaxTkIDs];
  float exitpz[kMaxAuxDets][kMaxTkIDs];
  int trackid[kMaxAuxDets][kMaxTkIDs];
  float energy[kMaxAuxDets][kMaxTkIDs];

  void ResetVars();

};


dune::CheckAuxDet::CheckAuxDet(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p),
  fLArG4ModuleLabel(p.get< std::string >("LArGeantModuleLabel", "largeant"))
{}

void dune::CheckAuxDet::analyze(art::Event const & evt)
{
  ResetVars();

  run = evt.run();
  subrun = evt.subRun();
  event = evt.id().event();

  std::vector<const sim::AuxDetSimChannel*> fAuxDetSimChannels;
  evt.getView(fLArG4ModuleLabel, fAuxDetSimChannels);

  nauxdets = fAuxDetSimChannels.size();

  for (size_t i = 0; i<fAuxDetSimChannels.size(); ++i){
    const sim::AuxDetSimChannel* c =  fAuxDetSimChannels[i];
    auxdetid[i] = c->AuxDetID();
    
    const std::vector<sim::AuxDetIDE>& setOfIDEs = c->AuxDetIDEs();
    ntrkids[i] = setOfIDEs.size();

    for (size_t j = 0; j<setOfIDEs.size(); ++j){
      entryx[i][j] = setOfIDEs[j].entryX;
      entryy[i][j] = setOfIDEs[j].entryY;
      entryz[i][j] = setOfIDEs[j].entryZ;
      entryt[i][j] = setOfIDEs[j].entryT;
      exitx[i][j] = setOfIDEs[j].exitX;
      exity[i][j] = setOfIDEs[j].exitY;
      exitz[i][j] = setOfIDEs[j].exitZ;
      exitt[i][j] = setOfIDEs[j].exitT;
      exitpx[i][j] = setOfIDEs[j].exitMomentumX;
      exitpy[i][j] = setOfIDEs[j].exitMomentumY;
      exitpz[i][j] = setOfIDEs[j].exitMomentumZ;
      energy[i][j] = setOfIDEs[j].energyDeposited;
      trackid[i][j] = setOfIDEs[j].trackID;
    }
  }
  fTree->Fill();
}

void dune::CheckAuxDet::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;
  fTree = tfs->make<TTree>("anatree","analysis tree");
  fTree->Branch("run",&run,"run/I");
  fTree->Branch("subrun",&subrun,"subrun/I");
  fTree->Branch("event",&event,"event/I");
  fTree->Branch("nauxdets",&nauxdets,"nauxdets/I");
  fTree->Branch("auxdetid",auxdetid,"auxdetid[nauxdets]/I");
  fTree->Branch("ntrkids",ntrkids,"ntrkids[nauxdets]/I");
  fTree->Branch("entryx",entryx,"entryx[nauxdets][100]/F");
  fTree->Branch("entryy",entryy,"entryy[nauxdets][100]/F");
  fTree->Branch("entryz",entryz,"entryz[nauxdets][100]/F");
  fTree->Branch("entryt",entryt,"entryt[nauxdets][100]/F");
  fTree->Branch("exitx",exitx,"exitx[nauxdets][100]/F");
  fTree->Branch("exity",exity,"exity[nauxdets][100]/F");
  fTree->Branch("exitz",exitz,"exitz[nauxdets][100]/F");
  fTree->Branch("exitt",exitt,"exitt[nauxdets][100]/F");
  fTree->Branch("trackid",trackid,"trackid[nauxdets][100]/I");
  fTree->Branch("energy",energy,"energy[nauxdets][100]/F");
  
}

void dune::CheckAuxDet::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
}

void dune::CheckAuxDet::ResetVars(){
  
  run = -99999;
  subrun = -99999;
  event = -99999;
  for (size_t i = 0; i<kMaxAuxDets; ++i){
    auxdetid[i] = -99999;
    ntrkids[i] = -99999;
    for (size_t j = 0; j<kMaxTkIDs; ++j){
      entryx[i][j] = -99999;
      entryy[i][j] = -99999;
      entryz[i][j] = -99999;
      entryt[i][j] = -99999;
      exitx[i][j] = -99999;
      exity[i][j] = -99999;
      exitz[i][j] = -99999;
      exitt[i][j] = -99999;
      exitpx[i][j] = -99999;
      exitpy[i][j] = -99999;
      exitpz[i][j] = -99999;
      trackid[i][j] = -99999;
      energy[i][j] = -99999;
    }
  }
}

DEFINE_ART_MODULE(dune::CheckAuxDet)
